# Redis Schema - Module TIR Auth

## ðŸŽ¯ ClÃ©s pour Authentification Administrateurs TIR Globaux

### Session Administrateur TIR

```
soins_suite_tir_admin_session:{token}
```

**Type :** HASH  
**TTL :** 7200s (2 heures)

**Contenu de la clÃ© :**

```json
{
  "admin_id": "550e8400-e29b-41d4-a716-446655440001",
  "identifiant": "admin_tir",
  "niveau_admin": "super_admin_tir",
  "peut_gerer_licences": "true",
  "peut_gerer_etablissements": "true",
  "peut_acceder_donnees_etablissement": "true",
  "peut_gerer_admins_globaux": "true",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
  "created_at": "2025-01-15T14:30:00Z",
  "last_activity": "2025-01-15T14:45:00Z",
  "expires_at": "2025-01-15T16:30:00Z"
}
```

## ðŸ“Š Configuration

| ClÃ©                      | Type | TTL   | Justification                                    |
| ------------------------ | ---- | ----- | ------------------------------------------------ |
| **tir_admin_session**    | HASH | 7200s | Sessions administrateurs (durÃ©e plus longue)    |

## ðŸ”„ StratÃ©gie d'Usage

### CrÃ©ation Session (Login TIR)

```go
func (s *TIRSessionService) CreateSession(ctx context.Context, data TIRSessionData) error {
    // Session TIR - Une seule clÃ© nÃ©cessaire
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", data.Token)
    
    err := s.redis.HMSet(ctx, sessionKey, data.ToMap()).Err()
    if err != nil {
        return err
    }
    
    return s.redis.Expire(ctx, sessionKey, 2*time.Hour).Err()
}
```

### Validation Session TIR

```go
func (s *TIRSessionService) ValidateSession(ctx context.Context, token string) (*TIRSession, error) {
    // Valider format token TIR
    if !strings.HasPrefix(token, "soins_suite_tir_admin_") {
        return nil, ErrInvalidTIRTokenFormat
    }
    
    // RÃ©cupÃ©rer session
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
    sessionData := s.redis.HGetAll(ctx, sessionKey).Val()
    
    if len(sessionData) == 0 {
        return nil, ErrTIRSessionNotFound
    }
    
    // Mettre Ã  jour last_activity
    s.redis.HSet(ctx, sessionKey, "last_activity", time.Now().Format(time.RFC3339))
    
    return parseTIRSession(sessionData), nil
}
```

### RÃ©vocation Session TIR (Logout)

```go
func (s *TIRSessionService) RevokeSession(ctx context.Context, token string) error {
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
    return s.redis.Del(ctx, sessionKey).Err()
}
```

## ðŸš€ Avantages SimplifiÃ©s

### **Architecture Minimaliste**

```
TOKEN: soins_suite_tir_admin_a1b2c3d4-e5f6-47h8-89i9-j0k1l2m3n4o5
REDIS: soins_suite_tir_admin_session:{token}
```

### **Performance OptimisÃ©e**

- **Session validation** : < 1ms (HGETALL unique)
- **Permissions en cache** : VÃ©rification directe dans session Redis
- **Pas de rate limiting** : Sessions administrateurs de confiance
- **TTL long** : 2h pour sessions administratives

### **SÃ©curitÃ© AdaptÃ©e**

- **Token prÃ©fixÃ©** : `soins_suite_tir_admin_` pour identification immÃ©diate
- **Sessions isolÃ©es** : ClÃ©s distinctes des utilisateurs normaux
- **TTL Ã©tendu** : AdaptÃ© aux tÃ¢ches administratives longues
- **RÃ©vocation simple** : DEL immÃ©diate sur logout

## ðŸ”§ Utilisation avec Middlewares TIR

### TIRSessionMiddleware

```go
func TIRSessionMiddleware(redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire token TIR
        token := extractBearerToken(c.GetHeader("Authorization"))
        if token == "" || !strings.HasPrefix(token, "soins_suite_tir_admin_") {
            c.AbortWithStatusJSON(401, gin.H{"error": "Token TIR requis"})
            return
        }
        
        // 2. Valider session TIR
        sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
        
        session := redis.HGetAll(c.Request.Context(), sessionKey).Val()
        if len(session) == 0 {
            c.AbortWithStatusJSON(460, gin.H{"error": "Session TIR invalide ou expirÃ©e"})
            return
        }
        
        // 3. Enrichir contexte
        c.Set("tir_session", session)
        c.Set("admin_id", session["admin_id"])
        c.Set("niveau_admin", session["niveau_admin"])
        
        // 4. Enrichir permissions TIR
        c.Set("peut_gerer_licences", session["peut_gerer_licences"] == "true")
        c.Set("peut_gerer_etablissements", session["peut_gerer_etablissements"] == "true")
        c.Set("peut_acceder_donnees_etablissement", session["peut_acceder_donnees_etablissement"] == "true")
        c.Set("peut_gerer_admins_globaux", session["peut_gerer_admins_globaux"] == "true")
        
        c.Next()
    }
}
```

### TIRPermissionMiddleware

```go
func TIRPermissionMiddleware(requiredPermission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // VÃ©rifier permission TIR spÃ©cifique
        hasPermission := false
        
        switch requiredPermission {
        case "gerer_licences":
            hasPermission = c.GetBool("peut_gerer_licences")
        case "gerer_etablissements":
            hasPermission = c.GetBool("peut_gerer_etablissements")
        case "acceder_donnees_etablissement":
            hasPermission = c.GetBool("peut_acceder_donnees_etablissement")
        case "gerer_admins_globaux":
            hasPermission = c.GetBool("peut_gerer_admins_globaux")
        default:
            c.AbortWithStatusJSON(400, gin.H{"error": "Permission TIR inconnue"})
            return
        }
        
        if !hasPermission {
            c.AbortWithStatusJSON(403, gin.H{
                "error": "Permission TIR insuffisante",
                "details": map[string]interface{}{
                    "required_permission": requiredPermission,
                    "admin_niveau": c.GetString("niveau_admin"),
                },
            })
            return
        }
        
        c.Next()
    }
}

// Utilisation dans routes
router.GET("/api/v1/tir/licenses",
    TIRSessionMiddleware(redis),
    TIRPermissionMiddleware("gerer_licences"),
    controller.GetLicenses,
)
```

## âš ï¸ RÃ¨gles d'Usage TIR

### **âœ… AUTORISÃ‰**

- Une seule clÃ© Redis par session avec permissions incluses
- TTL long (2h) pour sessions administratives
- Token prÃ©fixÃ© `soins_suite_tir_admin_`
- VÃ©rification permissions directe depuis cache Redis
- RÃ©vocation simple par DEL

### **âŒ INTERDIT**

- RÃ©utiliser les patterns multi-tenant Ã©tablissement
- ClÃ©s permissions sÃ©parÃ©es (tout dans session)
- Rate limiting sur admins TIR
- TTL courts (< 1h)

### **ðŸ’¡ RECOMMANDÃ‰**

- Logger toutes les actions administratives TIR
- Monitoring des sessions actives
- Validation stricte du format token

## ðŸ“Š MÃ©triques Ã  Surveiller

- **Sessions TIR actives** : `KEYS soins_suite_tir_admin_session:*`
- **DurÃ©e moyenne session** : DiffÃ©rence created_at/last_activity
- **Tentatives token invalides** : Compteur erreurs validation

## ðŸ”— IntÃ©gration avec Standards Existants

### **DiffÃ©rences avec Auth Utilisateurs**

| Aspect                  | Utilisateurs Standard              | Admins TIR                        |
| ----------------------- | ---------------------------------- | --------------------------------- |
| **Token Format**        | UUID simple                        | `soins_suite_tir_admin_{uuid}`    |
| **Headers**             | X-Establishment-Code + X-Client-Type | Authorization uniquement         |
| **ClÃ©s Redis**          | 3-4 clÃ©s (session + permissions)  | 1 seule clÃ©                       |
| **TTL**                 | 1h                                 | 2h                                |
| **Isolation**           | Multi-tenant par Ã©tablissement    | Global (pas d'Ã©tablissement)     |

### **Headers API TIR**

```http
# Login TIR
POST /api/v1/tir/auth/login
Content-Type: application/json
{
  "identifiant": "admin_tir",
  "password": "SecurePassword123!"
}

# Utilisation
GET /api/v1/tir/establishments
Authorization: Bearer soins_suite_tir_admin_a1b2c3d4-e5f6-47h8-89i9-j0k1l2m3n4o5
```

---

**ðŸ’¡ Note** : Ce schÃ©ma garantit une authentification TIR simple et performante, distincte du systÃ¨me multi-tenant utilisateurs, avec tous les droits par dÃ©faut pour les administrateurs globaux.