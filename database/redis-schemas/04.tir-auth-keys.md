# Redis Schema - Module TIR Auth

## 🎯 Clés pour Authentification Administrateurs TIR Globaux

### Session Administrateur TIR

```
soins_suite_tir_admin_session:{token}
```

**Type :** HASH  
**TTL :** 7200s (2 heures)

**Contenu de la clé :**

```json
{
  "admin_id": "550e8400-e29b-41d4-a716-446655440001",
  "identifiant": "admin_tir",
  "niveau_admin": "super_admin_tir",
  "peut_gerer_licences": "true",
  "peut_gerer_etablissements": "true",
  "peut_acceder_donnees_etablissement": "true",
  "peut_gerer_admins_globaux": "true",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
  "created_at": "2025-01-15T14:30:00Z",
  "last_activity": "2025-01-15T14:45:00Z",
  "expires_at": "2025-01-15T16:30:00Z"
}
```

## 📊 Configuration

| Clé                      | Type | TTL   | Justification                                    |
| ------------------------ | ---- | ----- | ------------------------------------------------ |
| **tir_admin_session**    | HASH | 7200s | Sessions administrateurs (durée plus longue)    |

## 🔄 Stratégie d'Usage

### Création Session (Login TIR)

```go
func (s *TIRSessionService) CreateSession(ctx context.Context, data TIRSessionData) error {
    // Session TIR - Une seule clé nécessaire
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", data.Token)
    
    err := s.redis.HMSet(ctx, sessionKey, data.ToMap()).Err()
    if err != nil {
        return err
    }
    
    return s.redis.Expire(ctx, sessionKey, 2*time.Hour).Err()
}
```

### Validation Session TIR

```go
func (s *TIRSessionService) ValidateSession(ctx context.Context, token string) (*TIRSession, error) {
    // Valider format token TIR
    if !strings.HasPrefix(token, "soins_suite_tir_admin_") {
        return nil, ErrInvalidTIRTokenFormat
    }
    
    // Récupérer session
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
    sessionData := s.redis.HGetAll(ctx, sessionKey).Val()
    
    if len(sessionData) == 0 {
        return nil, ErrTIRSessionNotFound
    }
    
    // Mettre à jour last_activity
    s.redis.HSet(ctx, sessionKey, "last_activity", time.Now().Format(time.RFC3339))
    
    return parseTIRSession(sessionData), nil
}
```

### Révocation Session TIR (Logout)

```go
func (s *TIRSessionService) RevokeSession(ctx context.Context, token string) error {
    sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
    return s.redis.Del(ctx, sessionKey).Err()
}
```

## 🚀 Avantages Simplifiés

### **Architecture Minimaliste**

```
TOKEN: soins_suite_tir_admin_a1b2c3d4-e5f6-47h8-89i9-j0k1l2m3n4o5
REDIS: soins_suite_tir_admin_session:{token}
```

### **Performance Optimisée**

- **Session validation** : < 1ms (HGETALL unique)
- **Permissions en cache** : Vérification directe dans session Redis
- **Pas de rate limiting** : Sessions administrateurs de confiance
- **TTL long** : 2h pour sessions administratives

### **Sécurité Adaptée**

- **Token préfixé** : `soins_suite_tir_admin_` pour identification immédiate
- **Sessions isolées** : Clés distinctes des utilisateurs normaux
- **TTL étendu** : Adapté aux tâches administratives longues
- **Révocation simple** : DEL immédiate sur logout

## 🔧 Utilisation avec Middlewares TIR

### TIRSessionMiddleware

```go
func TIRSessionMiddleware(redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire token TIR
        token := extractBearerToken(c.GetHeader("Authorization"))
        if token == "" || !strings.HasPrefix(token, "soins_suite_tir_admin_") {
            c.AbortWithStatusJSON(401, gin.H{"error": "Token TIR requis"})
            return
        }
        
        // 2. Valider session TIR
        sessionKey := fmt.Sprintf("soins_suite_tir_admin_session:%s", token)
        
        session := redis.HGetAll(c.Request.Context(), sessionKey).Val()
        if len(session) == 0 {
            c.AbortWithStatusJSON(460, gin.H{"error": "Session TIR invalide ou expirée"})
            return
        }
        
        // 3. Enrichir contexte
        c.Set("tir_session", session)
        c.Set("admin_id", session["admin_id"])
        c.Set("niveau_admin", session["niveau_admin"])
        
        // 4. Enrichir permissions TIR
        c.Set("peut_gerer_licences", session["peut_gerer_licences"] == "true")
        c.Set("peut_gerer_etablissements", session["peut_gerer_etablissements"] == "true")
        c.Set("peut_acceder_donnees_etablissement", session["peut_acceder_donnees_etablissement"] == "true")
        c.Set("peut_gerer_admins_globaux", session["peut_gerer_admins_globaux"] == "true")
        
        c.Next()
    }
}
```

### TIRPermissionMiddleware

```go
func TIRPermissionMiddleware(requiredPermission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // Vérifier permission TIR spécifique
        hasPermission := false
        
        switch requiredPermission {
        case "gerer_licences":
            hasPermission = c.GetBool("peut_gerer_licences")
        case "gerer_etablissements":
            hasPermission = c.GetBool("peut_gerer_etablissements")
        case "acceder_donnees_etablissement":
            hasPermission = c.GetBool("peut_acceder_donnees_etablissement")
        case "gerer_admins_globaux":
            hasPermission = c.GetBool("peut_gerer_admins_globaux")
        default:
            c.AbortWithStatusJSON(400, gin.H{"error": "Permission TIR inconnue"})
            return
        }
        
        if !hasPermission {
            c.AbortWithStatusJSON(403, gin.H{
                "error": "Permission TIR insuffisante",
                "details": map[string]interface{}{
                    "required_permission": requiredPermission,
                    "admin_niveau": c.GetString("niveau_admin"),
                },
            })
            return
        }
        
        c.Next()
    }
}

// Utilisation dans routes
router.GET("/api/v1/tir/licenses",
    TIRSessionMiddleware(redis),
    TIRPermissionMiddleware("gerer_licences"),
    controller.GetLicenses,
)
```

## ⚠️ Règles d'Usage TIR

### **✅ AUTORISÉ**

- Une seule clé Redis par session avec permissions incluses
- TTL long (2h) pour sessions administratives
- Token préfixé `soins_suite_tir_admin_`
- Vérification permissions directe depuis cache Redis
- Révocation simple par DEL

### **❌ INTERDIT**

- Réutiliser les patterns multi-tenant établissement
- Clés permissions séparées (tout dans session)
- Rate limiting sur admins TIR
- TTL courts (< 1h)

### **💡 RECOMMANDÉ**

- Logger toutes les actions administratives TIR
- Monitoring des sessions actives
- Validation stricte du format token

## 📊 Métriques à Surveiller

- **Sessions TIR actives** : `KEYS soins_suite_tir_admin_session:*`
- **Durée moyenne session** : Différence created_at/last_activity
- **Tentatives token invalides** : Compteur erreurs validation

## 🔗 Intégration avec Standards Existants

### **Différences avec Auth Utilisateurs**

| Aspect                  | Utilisateurs Standard              | Admins TIR                        |
| ----------------------- | ---------------------------------- | --------------------------------- |
| **Token Format**        | UUID simple                        | `soins_suite_tir_admin_{uuid}`    |
| **Headers**             | X-Establishment-Code + X-Client-Type | Authorization uniquement         |
| **Clés Redis**          | 3-4 clés (session + permissions)  | 1 seule clé                       |
| **TTL**                 | 1h                                 | 2h                                |
| **Isolation**           | Multi-tenant par établissement    | Global (pas d'établissement)     |

### **Headers API TIR**

```http
# Login TIR
POST /api/v1/tir/auth/login
Content-Type: application/json
{
  "identifiant": "admin_tir",
  "password": "SecurePassword123!"
}

# Utilisation
GET /api/v1/tir/establishments
Authorization: Bearer soins_suite_tir_admin_a1b2c3d4-e5f6-47h8-89i9-j0k1l2m3n4o5
```

---

**💡 Note** : Ce schéma garantit une authentification TIR simple et performante, distincte du système multi-tenant utilisateurs, avec tous les droits par défaut pour les administrateurs globaux.