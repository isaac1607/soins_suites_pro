# Redis Schema - Module Patients

## üéØ Cl√© pour R√©f√©rentiel Patient Unique

### Cache Patient Complet (Approche Minimaliste)

```
soins_suite_{etablissement}_patient_cache:{code_patient}
```

**Type :** HASH  
**TTL :** 3600s (1 heure)

**Contenu de la cl√© :**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440001",
  "code_patient": "CI-20250108-00001",
  "nom": "KOUADIO",
  "prenoms": "Jean Baptiste Marie",
  "date_naissance": "1985-06-15",
  "sexe": "M",
  "nationalite_id": "660e8400-e29b-41d4-a716-446655440002",
  "situation_matrimoniale_id": "770e8400-e29b-41d4-a716-446655440003",
  "telephone_principal": "+225 07 12 34 56 78",
  "telephone_secondaire": "+225 01 98 76 54 32",
  "email": "jean.kouadio@example.com",
  "adresse_complete": "Cocody, Angr√© 8√®me tranche, Villa 123",
  "ville": "Abidjan",
  "commune": "Cocody",
  "etablissement_createur_id": "880e8400-e29b-41d4-a716-446655440004",
  "est_assure": "true",
  "statut": "actif",
  "created_at": "2025-01-08T10:00:00Z",
  "updated_at": "2025-01-08T14:30:00Z",
  "assurances": "[{\"id\":\"990e8400-e29b-41d4-a716-446655440005\",\"nom\":\"MUGEF-CI\",\"numero\":\"MUGEF-2024-12345\",\"type\":\"principal\"}]"
}
```

## üìä Configuration

| Param√®tre        | Valeur              | Justification                        |
| ---------------- | ------------------- | ------------------------------------ |
| **TTL**          | 3600s (1 heure)     | √âquilibre performance/fra√Æcheur donn√©es |
| **Invalidation** | Manuelle sur modification | Cache invalid√© √† chaque mise √† jour patient |
| **Fallback**     | PostgreSQL + search_vector | Source de v√©rit√© pour recherches complexes |
| **Pattern**      | `patient`           | Conforme conventions projet - domaine unique |

## üîÑ Strat√©gie d'Usage

### Acc√®s Direct par Code Patient (95% des cas)

```go
// Cache hit - Performance optimale
func (s *PatientService) GetPatientByCode(ctx context.Context, codePatient string) (*PatientData, error) {
    key := fmt.Sprintf("soins_suite_patient:%s", codePatient)
    
    patientData := s.redis.HGetAll(ctx, key).Val()
    if len(patientData) == 0 {
        // Cache miss - charger depuis PostgreSQL
        patient, err := s.loadPatientFromDB(ctx, codePatient)
        if err != nil {
            return nil, err
        }
        
        // Warming cache imm√©diat
        s.cachePatient(ctx, patient)
        return patient, nil
    }
    
    return s.parsePatientFromCache(patientData), nil
}

// Warming cache apr√®s chargement DB
func (s *PatientService) cachePatient(ctx context.Context, patient *PatientData) {
    key := fmt.Sprintf("soins_suite_patient:%s", patient.CodePatient)
    
    // Conversion struct ‚Üí map Redis
    patientMap := map[string]interface{}{
        "id":                        patient.ID,
        "code_patient":              patient.CodePatient,
        "nom":                       patient.Nom,
        "prenoms":                   patient.Prenoms,
        "date_naissance":            patient.DateNaissance.Format("2006-01-02"),
        "sexe":                      patient.Sexe,
        "telephone_principal":       patient.TelephonePrincipal,
        "adresse_complete":          patient.AdresseComplete,
        "etablissement_createur_id": patient.EtablissementCreateurID,
        "est_assure":                fmt.Sprintf("%t", patient.EstAssure),
        "statut":                    patient.Statut,
        "created_at":                patient.CreatedAt.Format(time.RFC3339),
        "updated_at":                patient.UpdatedAt.Format(time.RFC3339),
    }
    
    // Assurances en JSON
    if len(patient.Assurances) > 0 {
        assurancesJSON, _ := json.Marshal(patient.Assurances)
        patientMap["assurances"] = string(assurancesJSON)
    }
    
    s.redis.HMSet(ctx, key, patientMap)
    s.redis.Expire(ctx, key, time.Hour)
}
```

### Recherche Complexe (5% des cas)

```go
// Pas de cache - Direct PostgreSQL avec search_vector
func (s *PatientService) SearchPatients(ctx context.Context, criteria SearchCriteria) ([]*PatientData, error) {
    // Utilisation du search_vector pour performance
    query := `
        SELECT code_patient, nom, prenoms, telephone_principal, statut
        FROM patients_patient 
        WHERE search_vector @@ plainto_tsquery('french', $1)
          AND statut = 'actif'
        ORDER BY ts_rank(search_vector, plainto_tsquery('french', $1)) DESC
        LIMIT 50`
    
    rows, err := s.db.Query(ctx, query, criteria.SearchTerm)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var patients []*PatientData
    for rows.Next() {
        var patient PatientData
        err := rows.Scan(&patient.CodePatient, &patient.Nom, &patient.Prenoms, 
                        &patient.TelephonePrincipal, &patient.Statut)
        if err != nil {
            continue
        }
        patients = append(patients, &patient)
    }
    
    // Pas de cache pour les r√©sultats de recherche (trop variable)
    return patients, nil
}
```

### Invalidation Cache

```go
// Invalidation simple sur modification
func (s *PatientService) UpdatePatient(ctx context.Context, codePatient string, updates *PatientUpdates) error {
    // 1. Transaction PostgreSQL
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 2. Mise √† jour base de donn√©es
    _, err = tx.Exec(ctx, `
        UPDATE patients_patient 
        SET nom = $2, prenoms = $3, telephone_principal = $4, updated_at = NOW()
        WHERE code_patient = $1`,
        codePatient, updates.Nom, updates.Prenoms, updates.TelephonePrincipal)
    
    if err != nil {
        return err
    }
    
    // 3. Commit transaction
    if err = tx.Commit(); err != nil {
        return err
    }
    
    // 4. Invalidation cache (apr√®s succ√®s DB)
    key := fmt.Sprintf("soins_suite_patient:%s", codePatient)
    s.redis.Del(ctx, key)
    
    return nil
}
```

### Cr√©ation Patient avec Anti-Doublon

```go
func (s *PatientService) CreatePatient(ctx context.Context, patient *CreatePatientRequest) (*PatientData, error) {
    // 1. V√©rification doublon PostgreSQL (pas de cache)
    exists, err := s.checkDuplicateInDB(ctx, patient.Nom, patient.Prenoms, patient.DateNaissance)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, ErrPatientDuplicate
    }
    
    // 2. G√©n√©ration code patient unique
    codePatient := s.generatePatientCode(ctx)
    
    // 3. Insertion PostgreSQL
    newPatient, err := s.insertPatientInDB(ctx, patient, codePatient)
    if err != nil {
        return nil, err
    }
    
    // 4. Warming cache imm√©diat
    s.cachePatient(ctx, newPatient)
    
    return newPatient, nil
}
```

## üöÄ Avantages Approche Minimaliste

### **Simplicit√© Maximale**

```go
// ‚úÖ 1 seule cl√© √† g√©rer
key := fmt.Sprintf("soins_suite_patient:%s", codePatient)

// ‚úÖ 1 seule invalidation
redis.Del(ctx, key)

// ‚úÖ 1 seul pattern de cache
redis.HMSet(ctx, key, patientData)
```

### **Performance Optimis√©e**

1. **Acc√®s direct** : < 1ms pour 95% des cas (par code_patient)
2. **Cache hit ratio** : 95%+ pour consultation patients
3. **M√©moire Redis** : Optimis√©e (1 cl√© vs 10 cl√©s complexes)
4. **Recherche complexe** : D√©l√©gu√© √† PostgreSQL + search_vector (optimis√©)

### **Maintenance Simplifi√©e**

- **Z√©ro logique complexe** : Pas de synchronisation multi-cl√©s
- **Invalidation triviale** : 1 DEL vs pipelines complexes
- **Debug facile** : 1 cl√© √† inspecter
- **Monitoring simple** : 1 m√©trique cache hit/miss

## üîß Utilisation dans Services

### Middleware d'Acc√®s Patient

```go
func PatientAccessMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        codePatient := c.Param("code_patient")
        if codePatient == "" {
            c.AbortWithStatusJSON(400, gin.H{"error": "Code patient requis"})
            return
        }
        
        // Chargement patient (cache automatique)
        patient, err := patientService.GetPatientByCode(c.Request.Context(), codePatient)
        if err != nil {
            if errors.Is(err, ErrPatientNotFound) {
                c.AbortWithStatusJSON(404, gin.H{"error": "Patient introuvable"})
                return
            }
            c.AbortWithStatusJSON(500, gin.H{"error": "Erreur serveur"})
            return
        }
        
        // V√©rification statut
        if patient.Statut != "actif" {
            c.AbortWithStatusJSON(403, gin.H{"error": "Patient inactif"})
            return
        }
        
        c.Set("patient", patient)
        c.Next()
    }
}
```

### Service Consultation Patient

```go
func (s *ConsultationService) CreateConsultation(ctx context.Context, codePatient string, consultation *ConsultationData) error {
    // Patient charg√© depuis cache automatiquement
    patient, err := s.patientService.GetPatientByCode(ctx, codePatient)
    if err != nil {
        return err
    }
    
    // Utilisation donn√©es patient cach√©es
    consultation.PatientID = patient.ID
    consultation.EstAssure = patient.EstAssure
    
    // Logique m√©tier consultation...
    return s.insertConsultation(ctx, consultation)
}
```

## ‚ö†Ô∏è R√®gles d'Usage

### **‚úÖ AUTORIS√â**

- Utiliser cette cl√© unique pour tous les acc√®s par code_patient
- Invalider sur toute modification patient (UPDATE)
- D√©l√©guer recherches complexes √† PostgreSQL + search_vector
- TTL 1 heure pour √©quilibre performance/fra√Æcheur

### **‚ùå INTERDIT**

- Cr√©er d'autres cl√©s pour m√™mes donn√©es patient
- Cacher les r√©sultats de recherche (trop variables)
- Utiliser pour stockage permanent (toujours un TTL)
- Modifier TTL sans justification m√©tier

### **üí° RECOMMAND√â**

- Monitoring cache hit ratio (objectif > 95%)
- Logs lors d'invalidation cache pour debug
- Warming proactif pour patients fr√©quemment consult√©s

## üìä M√©triques √† Surveiller

- **Cache hit ratio** : `GET soins_suite_patient:*` r√©ussis vs totaux
- **Latence cache hit** : < 1ms objectif
- **Latence cache miss** : < 50ms objectif (DB + cache warming)
- **Invalidations** : Fr√©quence DEL pour d√©tection anomalies

## üéØ Pattern Anti-Doublon Optionnel

Si la d√©tection de doublons devient critique, **1 seule cl√© suppl√©mentaire** peut √™tre ajout√©e :

```
soins_suite_patient_lock:{hash(nom+prenom+naissance)}
Type: STRING
TTL: 60s
Valeur: "etablissement_id"
```

**Usage limit√©** : Uniquement pendant cr√©ation patient, auto-expiration 1 minute.

---

**üí° Note** : Cette approche minimaliste couvre 95% des cas d'usage avec une complexit√© minimale. Pour les 5% restants (recherches), PostgreSQL avec search_vector est plus appropri√© qu'un cache complexe.