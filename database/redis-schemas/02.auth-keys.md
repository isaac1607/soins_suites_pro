# Redis Schema - Module Auth

## 🎯 Clés pour Authentification et Gestion des Sessions

### Session Utilisateur

```
soins_suite_{code_etablissement}_auth_session:{token}
```

**Type :** HASH  
**TTL :** 3600s (1 heure)

**Contenu de la clé :**

```json
{
  "user_id": "550e8400-e29b-41d4-a716-446655440001",
  "etablissement_id": "660e8400-e29b-41d4-a716-446655440002",
  "etablissement_code": "CENTREA",
  "client_type": "front-office",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
  "created_at": "2025-01-15T14:30:00Z",
  "last_activity": "2025-01-15T14:45:00Z",
  "expires_at": "2025-01-15T15:30:00Z"
}
```

### Permissions Utilisateur

```
soins_suite_{code_etablissement}_auth_permissions:{user_id}
```

**Type :** SET  
**TTL :** 3600s (1 heure)

**Membres du SET :**

```
module:ACCUEIL
module:CAISSE
module:CONSULTATION
rubrique:USERS:CREATE_USER
rubrique:USERS:VIEW_USER
rubrique:FACTURATION:ENCAISSEMENT
```

### Index Sessions Utilisateur

```
soins_suite_{code_etablissement}_auth_user_sessions:{user_id}
```

**Type :** SET  
**TTL :** 3600s (1 heure)

**Membres du SET :**

```
a1b2c3d4-e5f6-47h8-89i9-j0k1l2m3n4o5
b2c3d4e5-f6g7-48h9-90i0-k1l2m3n4o5p6
```

### Rate Limiting Login

```
soins_suite_{code_etablissement}_auth_ratelimit:{identifiant}
```

**Type :** STRING  
**TTL :** 900s (15 minutes)

**Valeur :**

```
5
```

## 📊 Configuration

| Clé                    | Type   | TTL   | Justification                           |
| ---------------------- | ------ | ----- | --------------------------------------- |
| **auth_session**       | HASH   | 3600s | Session complète avec métadonnées       |
| **auth_permissions**   | SET    | 3600s | Vérification rapide O(1) avec SISMEMBER |
| **auth_user_sessions** | SET    | 3600s | Multi-device, listing sessions actives  |
| **auth_ratelimit**     | STRING | 900s  | Protection brute-force 15 min           |
| **auth_blacklist**     | STRING | 3600s | Tokens révoqués avant expiration        |

## 🔄 Stratégie d'Usage

### Création Session (Login)

```go
func (s *SessionService) CreateSession(ctx context.Context, data SessionData) error {
    pipe := s.redis.Pipeline()

    // 1. Session principale
    sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
        data.EstablishmentCode, data.Token)
    pipe.HMSet(ctx, sessionKey, data.ToMap())
    pipe.Expire(ctx, sessionKey, time.Hour)

    // 2. Permissions utilisateur
    permissionsKey := fmt.Sprintf("soins_suite_%s_auth_permissions:%s",
        data.EstablishmentCode, data.UserID)
    for _, perm := range data.Permissions {
        pipe.SAdd(ctx, permissionsKey, perm)
    }
    pipe.Expire(ctx, permissionsKey, time.Hour)

    // 3. Index sessions utilisateur
    indexKey := fmt.Sprintf("soins_suite_%s_auth_user_sessions:%s",
        data.EstablishmentCode, data.UserID)
    pipe.SAdd(ctx, indexKey, data.Token)
    pipe.Expire(ctx, indexKey, time.Hour)

    _, err := pipe.Exec(ctx)
    return err
}
```

### Validation Session

```go
func (s *SessionService) ValidateSession(ctx context.Context, establishmentCode, token string) (*Session, error) {
    // 1. Vérifier blacklist
    blacklistKey := fmt.Sprintf("soins_suite_%s_auth_blacklist:%s",
        establishmentCode, token)
    if exists := s.redis.Exists(ctx, blacklistKey).Val(); exists > 0 {
        return nil, ErrTokenRevoked
    }

    // 2. Récupérer session
    sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
        establishmentCode, token)
    sessionData := s.redis.HGetAll(ctx, sessionKey).Val()

    if len(sessionData) == 0 {
        return nil, ErrSessionNotFound
    }

    // 3. Mettre à jour last_activity
    s.redis.HSet(ctx, sessionKey, "last_activity", time.Now().Format(time.RFC3339))

    return parseSession(sessionData), nil
}
```

### Vérification Permission

```go
func (s *PermissionService) CheckPermission(ctx context.Context, establishmentCode, userID, module, rubrique string) bool {
    permissionsKey := fmt.Sprintf("soins_suite_%s_auth_permissions:%s",
        establishmentCode, userID)

    // 1. Vérifier accès module complet
    moduleAccess := fmt.Sprintf("module:%s", module)
    if s.redis.SIsMember(ctx, permissionsKey, moduleAccess).Val() {
        return true
    }

    // 2. Vérifier accès rubrique spécifique
    if rubrique != "" {
        rubriqueAccess := fmt.Sprintf("rubrique:%s:%s", module, rubrique)
        return s.redis.SIsMember(ctx, permissionsKey, rubriqueAccess).Val()
    }

    return false
}
```

### Rate Limiting

```go
func (s *AuthService) CheckRateLimit(ctx context.Context, establishmentCode, identifiant string) error {
    key := fmt.Sprintf("soins_suite_%s_auth_ratelimit:%s",
        establishmentCode, identifiant)

    // Incrémenter compteur
    val := s.redis.Incr(ctx, key).Val()

    // Première tentative : définir TTL
    if val == 1 {
        s.redis.Expire(ctx, key, 15*time.Minute)
    }

    // Vérifier limite
    if val > 5 {
        ttl := s.redis.TTL(ctx, key).Val()
        return fmt.Errorf("rate limit exceeded, retry after %v", ttl)
    }

    return nil
}
```

### Révocation Session (Logout)

```go
func (s *SessionService) RevokeSession(ctx context.Context, establishmentCode, token, userID string) error {
    pipe := s.redis.Pipeline()

    // 1. Ajouter à blacklist
    blacklistKey := fmt.Sprintf("soins_suite_%s_auth_blacklist:%s",
        establishmentCode, token)
    pipe.Set(ctx, blacklistKey,
        fmt.Sprintf("revoked_at:%s", time.Now().Format(time.RFC3339)),
        time.Hour)

    // 2. Supprimer session
    sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
        establishmentCode, token)
    pipe.Del(ctx, sessionKey)

    // 3. Retirer de l'index utilisateur
    indexKey := fmt.Sprintf("soins_suite_%s_auth_user_sessions:%s",
        establishmentCode, userID)
    pipe.SRem(ctx, indexKey, token)

    _, err := pipe.Exec(ctx)
    return err
}
```

## 🚀 Avantages Multi-Tenant

### **Isolation Parfaite**

```
CENTREA  → soins_suite_CENTREA_auth_session:{token}
HOPITAL  → soins_suite_HOPITAL_auth_session:{token}
CLINIQUE → soins_suite_CLINIQUE_auth_session:{token}
```

### **Performance Optimisée**

- **Session validation** : < 1ms (HGETALL)
- **Permission check** : < 0.5ms (SISMEMBER)
- **Rate limit check** : < 0.5ms (INCR)
- **Multi-device support** : Index SET pour listing rapide

### **Sécurité Renforcée**

- **Blacklist** : Révocation immédiate des tokens
- **Rate limiting** : Protection brute-force par établissement
- **TTL cohérents** : Expiration automatique alignée
- **Isolation** : Aucune fuite entre établissements

## 🔧 Utilisation avec Middlewares

### SessionMiddleware

```go
func SessionMiddleware(redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire token
        token := extractBearerToken(c.GetHeader("Authorization"))
        if token == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "Token requis"})
            return
        }

        // 2. Extraire établissement
        establishmentCode := c.GetHeader("X-Establishment-Code")

        // 3. Valider session
        sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
            establishmentCode, token)

        session := redis.HGetAll(c.Request.Context(), sessionKey).Val()
        if len(session) == 0 {
            c.AbortWithStatusJSON(460, gin.H{"error": "Session invalide ou expirée"})
            return
        }

        // 4. Enrichir contexte
        c.Set("session", session)
        c.Set("user_id", session["user_id"])
        c.Next()
    }
}
```

### PermissionMiddleware

```go
func PermissionMiddleware(required string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        establishmentCode := c.GetHeader("X-Establishment-Code")

        permissionsKey := fmt.Sprintf("soins_suite_%s_auth_permissions:%s",
            establishmentCode, userID)

        // Vérifier permission
        if !redis.SIsMember(c.Request.Context(), permissionsKey, required).Val() {
            c.AbortWithStatusJSON(465, gin.H{
                "error": "Permissions insuffisantes",
                "details": map[string]interface{}{
                    "required": required,
                }
            })
            return
        }

        c.Next()
    }
}
```

## ⚠️ Règles d'Usage

### **✅ AUTORISÉ**

- Pipeline pour opérations multiples (login/logout)
- SISMEMBER pour vérifications rapides permissions
- TTL alignés pour cohérence (1h partout)
- Blacklist pour révocation avant expiration

### **❌ INTERDIT**

- Stocker mots de passe en Redis
- TTL différents entre session et permissions
- Clés sans établissement (violation multi-tenant)
- SMEMBERS sur permissions (utiliser SISMEMBER)

### **💡 RECOMMANDÉ**

- Utiliser Pipeline pour atomicité
- Logger tous les événements auth
- Monitoring des rate limits

## 📊 Métriques à Surveiller

- **Sessions actives** : `SCARD auth_user_sessions:*`
- **Rate limit hits** : Compteur tentatives > 5
- **Tokens blacklistés** : `KEYS auth_blacklist:*`
- **Latence validation** : Temps HGETALL + SISMEMBER

---

**💡 Note** : Ce schéma garantit une authentification performante (<2ms total), sécurisée (rate limiting + blacklist) et parfaitement isolée pour le multi-tenant.
