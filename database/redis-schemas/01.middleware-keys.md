# Redis Schema - Module Middleware

## 🎯 Clés pour Middlewares de Validation

### Cache Établissement (EstablishmentMiddleware)

```
soins_suite_{code_etablissement}_cache_middleware:establishment
```

**Contenu de la clé :**

```json
{
  "id": "uuid-etablissement-123",
  "app_instance": "uuid-app-instance-456", 
  "code": "CENTREA",
  "statut": "actif"
}
```

## 📊 Configuration

| Paramètre        | Valeur              | Justification                        |
| ---------------- | ------------------- | ------------------------------------ |
| **TTL**          | Infini (pas d'expiration) | Données immuables (ID, code établissement) |
| **Invalidation** | Manuelle uniquement | Cache invalidé si erreur de parsing ou suppression établissement |
| **Fallback**     | PostgreSQL          | Source de vérité (base_etablissement)|
| **Pattern**      | `cache_middleware`  | Conforme conventions projet         |

## 🔄 Stratégie d'Usage

### Dans l'EstablishmentMiddleware

```go
// Cache hit - Retour immédiat (performance optimale)
func (m *EstablishmentMiddleware) getEstablishmentFromCache(ctx context.Context, code string) (*EstablishmentData, bool) {
    jsonData, err := m.redisClient.GetWithPattern(ctx, "cache_middleware", code, "establishment")
    if err != nil {
        return nil, false // Cache miss normal
    }
    
    var establishment EstablishmentData
    if err := json.Unmarshal([]byte(jsonData), &establishment); err != nil {
        // Invalide le cache corrompu
        m.redisClient.DelWithPattern(ctx, "cache_middleware", code, "establishment")
        return nil, false
    }
    
    return &establishment, true
}

// Cache miss - Rebuild depuis PostgreSQL puis cache
func (m *EstablishmentMiddleware) cacheEstablishment(ctx context.Context, code string, establishment *EstablishmentData) {
    jsonData, err := json.Marshal(establishment)
    if err != nil {
        return // Continue sans cache en cas d'erreur
    }
    
    // Pas de TTL (données immuables ID/code établissement)
    m.redisClient.SetWithPattern(ctx, "cache_middleware", code, jsonData, "establishment")
}
```

## 🚀 Avantages Multi-Tenant

### **Isolation Parfaite**

```go
// Chaque établissement a son propre cache isolé
CENTREA  → soins_suite_CENTREA_cache_middleware:establishment
HOPITAL  → soins_suite_HOPITAL_cache_middleware:establishment
CLINIQUE → soins_suite_CLINIQUE_cache_middleware:establishment
```

### **Performance Optimisée EstablishmentMiddleware**

1. **1ère requête** : Database → Cache → Response (lent)  
2. **Toutes les suivantes** : Cache → Response (ultra-rapide permanent)
3. **Jamais d'expiration** : Performance constante maximale (données immuables)

**Impact mesurable :**
- ✅ **99,95% moins de requêtes PostgreSQL** vs sans cache
- ✅ **Latence < 1ms** après première requête  
- ✅ **Données immuables** : ID, app_instance, code établissement

### **Résilience**

- **Erreur Redis** : Fallback PostgreSQL transparent
- **Cache corrompu** : Auto-invalidation + rebuild
- **Établissement suspendu** : Validé en temps réel

## 🔧 Utilisation dans Autres Modules

Si un autre module a besoin des données d'établissement :

```go
// ✅ RÉUTILISER la même clé (pas de duplication)
func (s *MonAutreService) GetEstablishmentInfo(ctx context.Context, code string) (*EstablishmentData, error) {
    // Même pattern que le middleware
    jsonData, err := s.redisClient.GetWithPattern(ctx, "cache_middleware", code, "establishment")
    if err == redis.Nil {
        // Cache miss - aller chercher en DB puis cacher
        return s.loadAndCacheFromDB(ctx, code)
    }
    
    if err != nil {
        return nil, err
    }
    
    var establishment EstablishmentData
    json.Unmarshal([]byte(jsonData), &establishment)
    return &establishment, nil
}
```

## ⚠️ Règles d'Usage

### **✅ AUTORISÉ**
- Réutiliser cette clé dans d'autres services
- Partager la logique de cache entre modules
- Invalider manuellement si mise à jour établissement

### **❌ INTERDIT**
- Créer une autre clé pour les mêmes données
- Modifier le TTL sans justification
- Utiliser pour cacher d'autres types de données

---

## 🎯 Cache Licence (LicenseMiddleware)

### Clé Redis

```
soins_suite_{code_etablissement}_cache_middleware:license
```

**Contenu de la clé :**

```json
{
  "id": "uuid-licence-789",
  "type_licence": "standard",
  "mode_deploiement": "online", 
  "statut": "actif",
  "modules_autorises": ["ACCUEIL", "CAISSE", "INFIRMERIE"],
  "date_expiration": "2026-01-15T00:00:00Z"
}
```

## 📊 Configuration Cache Licence

| Paramètre        | Valeur              | Justification                        |
| ---------------- | ------------------- | ------------------------------------ |
| **TTL**          | 24 heures (86400s)  | Données critiques, refresh quotidien |
| **Invalidation** | Manuelle + TTL      | Cache invalidé si licence modifiée  |
| **Fallback**     | PostgreSQL          | Source de vérité (base_licence)      |
| **Pattern**      | `cache_middleware`  | Conforme conventions projet         |

### 🔄 Utilisation dans LicenseMiddleware

```go
// Cache licence optimisé - données critiques uniquement
type LicenseData struct {
    ID               string   `json:"id"`
    TypeLicence      string   `json:"type_licence"`       // premium|standard|evaluation
    ModeDeploiement  string   `json:"mode_deploiement"`   // local|online
    Statut           string   `json:"statut"`             // actif|expiree|revoquee
    ModulesAutorises []string `json:"modules_autorises"`  // JSONB array
    DateExpiration   *string  `json:"date_expiration"`    // NULL pour premium local
}

// Cache hit - Performance optimale 24h
func (m *LicenseMiddleware) getLicenseFromCache(ctx context.Context, establishmentID string) (*LicenseData, bool) {
    jsonData, err := m.redisClient.GetWithPattern(ctx, "cache_middleware", establishmentID, "license")
    if err != nil {
        return nil, false // Cache miss normal
    }
    
    var license LicenseData
    if err := json.Unmarshal([]byte(jsonData), &license); err != nil {
        // Invalide le cache corrompu
        m.redisClient.DelWithPattern(ctx, "cache_middleware", establishmentID, "license")
        return nil, false
    }
    
    return &license, true
}
```

### ⚡ Avantages TTL 24h pour Licence

1. **Données semi-statiques** : Licence change rarement
2. **Performance critique** : Middleware appelé sur chaque requête
3. **Validation quotidienne** : Contrôle expiration une fois/jour suffisant
4. **Optimisation BD** : 1440 fois moins de requêtes vs sans cache

### 🚨 Invalidation Manuelle Requise

```go
// Quand licence modifiée (très rare)
func InvalidateLicenseCache(ctx context.Context, establishmentID string) {
    redisClient.DelWithPattern(ctx, "cache_middleware", establishmentID, "license")
}
```

---

**💡 Note** : Ces deux caches middleware sont les **modèles de référence** pour tous les caches de validation. Respecter ces patterns pour cohérence.