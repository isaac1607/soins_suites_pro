# Redis Schema - Module Middleware

## ğŸ¯ ClÃ©s pour Middlewares de Validation

### Cache Ã‰tablissement (EstablishmentMiddleware)

```
soins_suite_{code_etablissement}_cache_middleware:establishment
```

**Contenu de la clÃ© :**

```json
{
  "id": "uuid-etablissement-123",
  "app_instance": "uuid-app-instance-456", 
  "code": "CENTREA",
  "statut": "actif"
}
```

## ğŸ“Š Configuration

| ParamÃ¨tre        | Valeur              | Justification                        |
| ---------------- | ------------------- | ------------------------------------ |
| **TTL**          | Infini (pas d'expiration) | DonnÃ©es immuables (ID, code Ã©tablissement) |
| **Invalidation** | Manuelle uniquement | Cache invalidÃ© si erreur de parsing ou suppression Ã©tablissement |
| **Fallback**     | PostgreSQL          | Source de vÃ©ritÃ© (base_etablissement)|
| **Pattern**      | `cache_middleware`  | Conforme conventions projet         |

## ğŸ”„ StratÃ©gie d'Usage

### Dans l'EstablishmentMiddleware

```go
// Cache hit - Retour immÃ©diat (performance optimale)
func (m *EstablishmentMiddleware) getEstablishmentFromCache(ctx context.Context, code string) (*EstablishmentData, bool) {
    jsonData, err := m.redisClient.GetWithPattern(ctx, "cache_middleware", code, "establishment")
    if err != nil {
        return nil, false // Cache miss normal
    }
    
    var establishment EstablishmentData
    if err := json.Unmarshal([]byte(jsonData), &establishment); err != nil {
        // Invalide le cache corrompu
        m.redisClient.DelWithPattern(ctx, "cache_middleware", code, "establishment")
        return nil, false
    }
    
    return &establishment, true
}

// Cache miss - Rebuild depuis PostgreSQL puis cache
func (m *EstablishmentMiddleware) cacheEstablishment(ctx context.Context, code string, establishment *EstablishmentData) {
    jsonData, err := json.Marshal(establishment)
    if err != nil {
        return // Continue sans cache en cas d'erreur
    }
    
    // Pas de TTL (donnÃ©es immuables ID/code Ã©tablissement)
    m.redisClient.SetWithPattern(ctx, "cache_middleware", code, jsonData, "establishment")
}
```

## ğŸš€ Avantages Multi-Tenant

### **Isolation Parfaite**

```go
// Chaque Ã©tablissement a son propre cache isolÃ©
CENTREA  â†’ soins_suite_CENTREA_cache_middleware:establishment
HOPITAL  â†’ soins_suite_HOPITAL_cache_middleware:establishment
CLINIQUE â†’ soins_suite_CLINIQUE_cache_middleware:establishment
```

### **Performance OptimisÃ©e EstablishmentMiddleware**

1. **1Ã¨re requÃªte** : Database â†’ Cache â†’ Response (lent)  
2. **Toutes les suivantes** : Cache â†’ Response (ultra-rapide permanent)
3. **Jamais d'expiration** : Performance constante maximale (donnÃ©es immuables)

**Impact mesurable :**
- âœ… **99,95% moins de requÃªtes PostgreSQL** vs sans cache
- âœ… **Latence < 1ms** aprÃ¨s premiÃ¨re requÃªte  
- âœ… **DonnÃ©es immuables** : ID, app_instance, code Ã©tablissement

### **RÃ©silience**

- **Erreur Redis** : Fallback PostgreSQL transparent
- **Cache corrompu** : Auto-invalidation + rebuild
- **Ã‰tablissement suspendu** : ValidÃ© en temps rÃ©el

## ğŸ”§ Utilisation dans Autres Modules

Si un autre module a besoin des donnÃ©es d'Ã©tablissement :

```go
// âœ… RÃ‰UTILISER la mÃªme clÃ© (pas de duplication)
func (s *MonAutreService) GetEstablishmentInfo(ctx context.Context, code string) (*EstablishmentData, error) {
    // MÃªme pattern que le middleware
    jsonData, err := s.redisClient.GetWithPattern(ctx, "cache_middleware", code, "establishment")
    if err == redis.Nil {
        // Cache miss - aller chercher en DB puis cacher
        return s.loadAndCacheFromDB(ctx, code)
    }
    
    if err != nil {
        return nil, err
    }
    
    var establishment EstablishmentData
    json.Unmarshal([]byte(jsonData), &establishment)
    return &establishment, nil
}
```

## âš ï¸ RÃ¨gles d'Usage

### **âœ… AUTORISÃ‰**
- RÃ©utiliser cette clÃ© dans d'autres services
- Partager la logique de cache entre modules
- Invalider manuellement si mise Ã  jour Ã©tablissement

### **âŒ INTERDIT**
- CrÃ©er une autre clÃ© pour les mÃªmes donnÃ©es
- Modifier le TTL sans justification
- Utiliser pour cacher d'autres types de donnÃ©es

---

## ğŸ¯ Cache Licence (LicenseMiddleware)

### ClÃ© Redis

```
soins_suite_{code_etablissement}_cache_middleware:license
```

**Contenu de la clÃ© :**

```json
{
  "id": "uuid-licence-789",
  "type_licence": "standard",
  "mode_deploiement": "online", 
  "statut": "actif",
  "modules_autorises": ["ACCUEIL", "CAISSE", "INFIRMERIE"],
  "date_expiration": "2026-01-15T00:00:00Z"
}
```

## ğŸ“Š Configuration Cache Licence

| ParamÃ¨tre        | Valeur              | Justification                        |
| ---------------- | ------------------- | ------------------------------------ |
| **TTL**          | 24 heures (86400s)  | DonnÃ©es critiques, refresh quotidien |
| **Invalidation** | Manuelle + TTL      | Cache invalidÃ© si licence modifiÃ©e  |
| **Fallback**     | PostgreSQL          | Source de vÃ©ritÃ© (base_licence)      |
| **Pattern**      | `cache_middleware`  | Conforme conventions projet         |

### ğŸ”„ Utilisation dans LicenseMiddleware

```go
// Cache licence optimisÃ© - donnÃ©es critiques uniquement
type LicenseData struct {
    ID               string   `json:"id"`
    TypeLicence      string   `json:"type_licence"`       // premium|standard|evaluation
    ModeDeploiement  string   `json:"mode_deploiement"`   // local|online
    Statut           string   `json:"statut"`             // actif|expiree|revoquee
    ModulesAutorises []string `json:"modules_autorises"`  // JSONB array
    DateExpiration   *string  `json:"date_expiration"`    // NULL pour premium local
}

// Cache hit - Performance optimale 24h
func (m *LicenseMiddleware) getLicenseFromCache(ctx context.Context, establishmentID string) (*LicenseData, bool) {
    jsonData, err := m.redisClient.GetWithPattern(ctx, "cache_middleware", establishmentID, "license")
    if err != nil {
        return nil, false // Cache miss normal
    }
    
    var license LicenseData
    if err := json.Unmarshal([]byte(jsonData), &license); err != nil {
        // Invalide le cache corrompu
        m.redisClient.DelWithPattern(ctx, "cache_middleware", establishmentID, "license")
        return nil, false
    }
    
    return &license, true
}
```

### âš¡ Avantages TTL 24h pour Licence

1. **DonnÃ©es semi-statiques** : Licence change rarement
2. **Performance critique** : Middleware appelÃ© sur chaque requÃªte
3. **Validation quotidienne** : ContrÃ´le expiration une fois/jour suffisant
4. **Optimisation BD** : 1440 fois moins de requÃªtes vs sans cache

### ğŸš¨ Invalidation Manuelle Requise

```go
// Quand licence modifiÃ©e (trÃ¨s rare)
func InvalidateLicenseCache(ctx context.Context, establishmentID string) {
    redisClient.DelWithPattern(ctx, "cache_middleware", establishmentID, "license")
}
```

---

**ğŸ’¡ Note** : Ces deux caches middleware sont les **modÃ¨les de rÃ©fÃ©rence** pour tous les caches de validation. Respecter ces patterns pour cohÃ©rence.