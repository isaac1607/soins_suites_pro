# SP√âCIFICATIONS TECHNIQUES - MIDDLEWARES CORE

## üìã Informations G√©n√©rales

- **Module :** Middlewares Infrastructure
- **Version :** 1.0 MVP
- **Priorit√© :** Must Have (Core Infrastructure)
- **Architecture :** Gin Middleware Chain

## üéØ Objectif

D√©velopper une cha√Æne de middlewares robuste pour :

- S√©curit√© multi-tenant avec isolation stricte
- Authentification et autorisation granulaire
- Performance et observabilit√©
- Gestion d'erreurs coh√©rente

## üèóÔ∏è Architecture Middleware Chain

```
Request Flow:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Request ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
[RecoveryMiddleware]     // Panic recovery
     ‚Üì
[LoggerMiddleware]       // Request/Response logging
     ‚Üì
[CORSMiddleware]         // CORS headers
     ‚Üì
[SecurityMiddleware]     // Security headers
     ‚Üì
[EstablishmentMiddleware] // Multi-tenant validation
     ‚Üì
[LicenseMiddleware]      // License validation
     ‚Üì
[SessionMiddleware]      // Auth validation
     ‚Üì
[PermissionMiddleware]   // Permission check
     ‚Üì
[RateLimitMiddleware]    // Rate limiting
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Controller ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üìÅ Structure des Fichiers

```
internal/shared/middleware/
‚îú‚îÄ‚îÄ middleware.module.go              # Module Fx principal
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ recovery.middleware.go       # Panic recovery
‚îÇ   ‚îú‚îÄ‚îÄ logger.middleware.go         # Request logging
‚îÇ   ‚îî‚îÄ‚îÄ errors.middleware.go         # Error handling
‚îú‚îÄ‚îÄ security/
‚îÇ   ‚îú‚îÄ‚îÄ cors.middleware.go           # CORS configuration
‚îÇ   ‚îú‚îÄ‚îÄ security.middleware.go       # Security headers
‚îÇ   ‚îî‚îÄ‚îÄ ratelimit.middleware.go      # Rate limiting
‚îú‚îÄ‚îÄ tenant/
‚îÇ   ‚îú‚îÄ‚îÄ establishment.middleware.go  # Multi-tenant
‚îÇ   ‚îî‚îÄ‚îÄ license.middleware.go        # License check
‚îî‚îÄ‚îÄ auth/
    ‚îú‚îÄ‚îÄ session.middleware.go        # Session validation
    ‚îî‚îÄ‚îÄ permission.middleware.go     # Permission check
```

---

## üîß MIDDLEWARE 1: RecoveryMiddleware

### **Responsabilit√©s**

- Capture des panics
- Logging des stack traces
- R√©ponse d'erreur propre

### **Implementation**

```go
func RecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Log stack trace
                stack := make([]byte, 4096)
                n := runtime.Stack(stack, false)

                log.Error("panic recovered",
                    "error", err,
                    "stack", string(stack[:n]),
                    "path", c.Request.URL.Path,
                )

                c.AbortWithStatusJSON(500, gin.H{
                    "error": "Une erreur interne s'est produite",
                    "details": map[string]interface{}{
                        "code": "INTERNAL_ERROR",
                        "request_id": c.GetString("request_id"),
                    },
                })
            }
        }()
        c.Next()
    }
}
```

---

## üîß MIDDLEWARE 2: LoggerMiddleware

### **Responsabilit√©s**

- G√©n√©ration request_id unique
- Logging requ√™te/r√©ponse
- Mesure latence

### **Implementation**

```go
func LoggerMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // G√©n√©rer request_id
        requestID := uuid.New().String()
        c.Set("request_id", requestID)

        // Start timer
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery

        // Process request
        c.Next()

        // Log apr√®s traitement
        latency := time.Since(start)
        clientIP := c.ClientIP()
        method := c.Request.Method
        statusCode := c.Writer.Status()

        if raw != "" {
            path = path + "?" + raw
        }

        log.Info("request processed",
            "request_id", requestID,
            "method", method,
            "path", path,
            "status", statusCode,
            "latency_ms", latency.Milliseconds(),
            "client_ip", clientIP,
            "establishment", c.GetHeader("X-Establishment-Code"),
        )
    }
}
```

---

## üîß MIDDLEWARE 3: CORSMiddleware

### **Responsabilit√©s**

- Configuration CORS pour multi-tenant
- Support des sous-domaines dynamiques

### **Implementation**

```go
func CORSMiddleware(config *config.AppConfig) gin.HandlerFunc {
    return cors.New(cors.Config{
        AllowOriginFunc: func(origin string) bool {
            // Autoriser tous les sous-domaines *.soins-suite.tir.ci
            allowedPattern := regexp.MustCompile(
                `^https?://([a-zA-Z0-9-]+\.)?(back-office\.)?soins-suite\.tir\.ci$`,
            )
            return allowedPattern.MatchString(origin) ||
                   origin == "http://localhost:3000" // Dev
        },
        AllowMethods: []string{
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH",
        },
        AllowHeaders: []string{
            "Origin", "Content-Type", "Authorization",
            "X-Establishment-Code", "X-Client-Type",
        },
        ExposeHeaders: []string{
            "Content-Length", "X-Request-Id",
        },
        AllowCredentials: true,
        MaxAge: 12 * time.Hour,
    })
}
```

---

## üîß MIDDLEWARE 4: SecurityMiddleware

### **Responsabilit√©s**

- Headers de s√©curit√© (CSP, HSTS, etc.)
- Protection XSS/Clickjacking

### **Implementation**

```go
func SecurityMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Security headers
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

        // HSTS pour production
        if gin.Mode() == gin.ReleaseMode {
            c.Header("Strict-Transport-Security",
                "max-age=31536000; includeSubDomains; preload")
        }

        // CSP basique
        c.Header("Content-Security-Policy",
            "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'")

        c.Next()
    }
}
```

---

## üîß MIDDLEWARE 5: EstablishmentMiddleware

### **Responsabilit√©s**

- Validation code √©tablissement
- V√©rification existence et statut
- Injection contexte √©tablissement
- Cache Redis pour performance

### **Implementation**

```go
func EstablishmentMiddleware(db *postgres.Client, redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire code √©tablissement
        code := c.GetHeader("X-Establishment-Code")
        if code == "" {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Code √©tablissement requis",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_CODE_REQUIRED",
                    "header_required": "X-Establishment-Code",
                },
            })
            return
        }

        // 2. Validation format
        if !isValidEstablishmentCode(code) {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Format code √©tablissement invalide",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_CODE_INVALID_FORMAT",
                    "format_requis": "3-20 caract√®res alphanum√©riques majuscules",
                },
            })
            return
        }

        // 3. V√©rifier cache Redis
        cacheKey := fmt.Sprintf("soins_suite_%s_cache_middleware:establishment", code)
        cached, err := redis.Get(c.Request.Context(), cacheKey).Result()

        var establishment EstablishmentData
        if err == nil {
            // Cache hit
            json.Unmarshal([]byte(cached), &establishment)
        } else {
            // Cache miss - requ√™te DB
            err = db.QueryRow(c.Request.Context(),
                `SELECT id, app_instance, code_etablissement, statut, nom
                 FROM base_etablissement
                 WHERE code_etablissement = $1`, code).Scan(
                &establishment.ID,
                &establishment.AppInstance,
                &establishment.Code,
                &establishment.Statut,
                &establishment.Nom,
            )

            if err != nil {
                c.AbortWithStatusJSON(460, gin.H{
                    "error": "√âtablissement non trouv√©",
                    "details": map[string]interface{}{
                        "code": "ESTABLISHMENT_NOT_FOUND",
                        "establishment_code": code,
                    },
                })
                return
            }

            // Mettre en cache (pas d'expiration car donn√©es immuables)
            jsonData, _ := json.Marshal(establishment)
            redis.Set(c.Request.Context(), cacheKey, jsonData, 0)
        }

        // 4. V√©rifier statut
        if establishment.Statut != "actif" {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "√âtablissement suspendu",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_SUSPENDED",
                    "establishment_code": code,
                    "statut": establishment.Statut,
                },
            })
            return
        }

        // 5. Enrichir contexte
        c.Set("establishment", establishment)
        c.Set("establishment_id", establishment.ID)
        c.Set("establishment_code", code)

        c.Next()
    }
}
```

### **Routes Exempt√©es**

```go
var EstablishmentExemptPaths = []string{
    "/health",
    "/ready",
    "/metrics",
    "/api/v1/system/ping",
}
```

---

## üîß MIDDLEWARE 6: LicenseMiddleware

### **Responsabilit√©s**

- V√©rification licence active
- Contr√¥le expiration
- Validation modules autoris√©s
- Cache Redis 24h

### **Implementation**

```go
func LicenseMiddleware(db *postgres.Client, redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        establishmentID := c.GetString("establishment_id")

        // 1. V√©rifier cache Redis
        cacheKey := fmt.Sprintf("soins_suite_%s_cache_middleware:license",
            c.GetString("establishment_code"))

        var license LicenseData
        cached, err := redis.Get(c.Request.Context(), cacheKey).Result()

        if err == nil {
            json.Unmarshal([]byte(cached), &license)
        } else {
            // Cache miss - requ√™te DB
            err = db.QueryRow(c.Request.Context(),
                `SELECT l.id, l.type_licence, l.mode_deploiement,
                        l.statut, l.modules_autorises, l.date_expiration
                 FROM base_licence l
                 WHERE l.etablissement_id = $1
                   AND l.statut = 'actif'
                 ORDER BY l.created_at DESC
                 LIMIT 1`, establishmentID).Scan(
                &license.ID,
                &license.TypeLicence,
                &license.ModeDeploiement,
                &license.Statut,
                &license.ModulesAutorises,
                &license.DateExpiration,
            )

            if err != nil {
                c.AbortWithStatusJSON(465, gin.H{
                    "error": "Aucune licence trouv√©e",
                    "details": map[string]interface{}{
                        "code": "LICENSE_NOT_FOUND",
                        "establishment_code": c.GetString("establishment_code"),
                    },
                })
                return
            }

            // Cache 24h
            jsonData, _ := json.Marshal(license)
            redis.Set(c.Request.Context(), cacheKey, jsonData, 24*time.Hour)
        }

        // 2. V√©rifier expiration (mode online uniquement)
        if license.ModeDeploiement == "online" && license.DateExpiration != nil {
            if time.Now().After(*license.DateExpiration) {
                c.AbortWithStatusJSON(465, gin.H{
                    "error": "Licence expir√©e",
                    "details": map[string]interface{}{
                        "code": "LICENSE_EXPIRED",
                        "expiration_date": license.DateExpiration,
                    },
                })
                return
            }
        }

        // 3. Enrichir contexte
        c.Set("license", license)
        c.Set("modules_autorises", license.ModulesAutorises)

        c.Next()
    }
}
```

---

## üîß MIDDLEWARE 7: SessionMiddleware

### **Responsabilit√©s**

- Validation token Bearer
- V√©rification session Redis
- Enrichissement contexte utilisateur
- Mise √† jour last_activity

### **Implementation**

```go
func SessionMiddleware(redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Token requis",
                "details": map[string]interface{}{
                    "code": "TOKEN_REQUIRED",
                },
            })
            return
        }

        // Format: Bearer {token}
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Format token invalide",
                "details": map[string]interface{}{
                    "code": "INVALID_TOKEN_FORMAT",
                },
            })
            return
        }

        token := parts[1]
        establishmentCode := c.GetString("establishment_code")

        // 2. V√©rifier blacklist
        blacklistKey := fmt.Sprintf("soins_suite_%s_auth_blacklist:%s",
            establishmentCode, token)
        if exists := redis.Exists(c.Request.Context(), blacklistKey).Val(); exists > 0 {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Token r√©voqu√©",
                "details": map[string]interface{}{
                    "code": "TOKEN_REVOKED",
                },
            })
            return
        }

        // 3. R√©cup√©rer session
        sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
            establishmentCode, token)
        sessionData := redis.HGetAll(c.Request.Context(), sessionKey).Val()

        if len(sessionData) == 0 {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Session invalide ou expir√©e",
                "details": map[string]interface{}{
                    "code": "SESSION_NOT_FOUND",
                },
            })
            return
        }

        // 4. Mettre √† jour last_activity
        redis.HSet(c.Request.Context(), sessionKey,
            "last_activity", time.Now().Format(time.RFC3339))
        redis.Expire(c.Request.Context(), sessionKey, time.Hour)

        // 5. Enrichir contexte
        c.Set("session", sessionData)
        c.Set("user_id", sessionData["user_id"])
        c.Set("client_type", sessionData["client_type"])
        c.Set("token", token)

        c.Next()
    }
}
```

---

## üîß MIDDLEWARE 8: PermissionMiddleware

### **Responsabilit√©s**

- V√©rification permissions requises
- Support module/rubrique
- Cache Redis des permissions

### **Implementation**

```go
func PermissionMiddleware(required string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        establishmentCode := c.GetString("establishment_code")

        if userID == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Authentification requise",
                "details": map[string]interface{}{
                    "code": "AUTH_REQUIRED",
                },
            })
            return
        }

        // R√©cup√©rer permissions depuis Redis
        permissionsKey := fmt.Sprintf("soins_suite_%s_auth_permissions:%s",
            establishmentCode, userID)

        // Parser permission requise
        parts := strings.Split(required, ":")
        permType := parts[0]  // "module" ou "rubrique"

        var hasPermission bool

        if permType == "module" {
            // V√©rifier acc√®s module complet
            hasPermission = redis.SIsMember(c.Request.Context(),
                permissionsKey, required).Val()
        } else if permType == "rubrique" && len(parts) == 3 {
            // V√©rifier acc√®s rubrique OU module complet
            module := parts[1]
            moduleAccess := fmt.Sprintf("module:%s", module)

            hasModuleAccess := redis.SIsMember(c.Request.Context(),
                permissionsKey, moduleAccess).Val()
            hasRubriqueAccess := redis.SIsMember(c.Request.Context(),
                permissionsKey, required).Val()

            hasPermission = hasModuleAccess || hasRubriqueAccess
        }

        if !hasPermission {
            c.AbortWithStatusJSON(465, gin.H{
                "error": "Permissions insuffisantes",
                "details": map[string]interface{}{
                    "code": "INSUFFICIENT_PERMISSIONS",
                    "required": required,
                },
            })
            return
        }

        c.Next()
    }
}
```

---

## üîß MIDDLEWARE 9: RateLimitMiddleware

### **Responsabilit√©s**

- Protection contre les abus
- Limitation par endpoint/utilisateur
- Sliding window avec Redis

### **Implementation**

```go
func RateLimitMiddleware(limit int, window time.Duration) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        if userID == "" {
            userID = c.ClientIP() // Fallback sur IP si non authentifi√©
        }

        path := c.Request.URL.Path
        method := c.Request.Method
        establishmentCode := c.GetString("establishment_code")

        // Cl√© unique par utilisateur/endpoint
        key := fmt.Sprintf("soins_suite_%s_ratelimit:%s:%s:%s",
            establishmentCode, userID, method, path)

        // Incr√©menter compteur
        val := redis.Incr(c.Request.Context(), key).Val()

        // Premi√®re requ√™te : d√©finir TTL
        if val == 1 {
            redis.Expire(c.Request.Context(), key, window)
        }

        // V√©rifier limite
        if val > int64(limit) {
            ttl := redis.TTL(c.Request.Context(), key).Val()
            c.AbortWithStatusJSON(429, gin.H{
                "error": "Trop de requ√™tes",
                "details": map[string]interface{}{
                    "code": "RATE_LIMIT_EXCEEDED",
                    "retry_after_seconds": int(ttl.Seconds()),
                },
            })
            return
        }

        // Headers informatifs
        c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
        c.Header("X-RateLimit-Remaining", strconv.Itoa(limit-int(val)))

        c.Next()
    }
}
```

---

## üìã Configuration des Routes - Exemples Pratiques

### **Routes PUBLIQUES (sans authentification)**

```go
// Routes accessibles sans token
public := router.Group("/api/v1")
public.Use(
    RecoveryMiddleware(),           // Protection panics
    LoggerMiddleware(),              // Logging
    CORSMiddleware(config),          // CORS
    SecurityMiddleware(),            // Headers s√©curit√©
    EstablishmentMiddleware(db, redis), // Multi-tenant OBLIGATOIRE
)
{
    // Login - pas besoin de SessionMiddleware car c'est ici qu'on cr√©e la session
    public.POST("/auth/login",
        RateLimitMiddleware(5, 15*time.Minute), // Max 5 tentatives / 15 min
        authController.Login,
    )

    // Endpoints syst√®me publics
    public.GET("/system/ping", systemController.Ping)
    public.GET("/health", healthController.Check)
}
```

### **Routes PROT√âG√âES SIMPLES (auth requise, pas de permission sp√©cifique)**

```go
// Routes n√©cessitant juste d'√™tre connect√©
authenticated := router.Group("/api/v1")
authenticated.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),        // ‚úÖ OBLIGATOIRE - V√©rifie token valide
    // PAS de PermissionMiddleware ici - juste besoin d'√™tre connect√©
)
{
    // Endpoints accessibles √† tous les utilisateurs connect√©s
    authenticated.GET("/auth/me", authController.GetCurrentUser)
    authenticated.POST("/auth/logout", authController.Logout)
    authenticated.POST("/auth/refresh", authController.RefreshToken)
    authenticated.GET("/profile", userController.GetMyProfile)
}
```

### **Routes PROT√âG√âES avec PERMISSIONS (module complet)**

```go
// Routes n√©cessitant des permissions sp√©cifiques
adminRoutes := router.Group("/api/v1/admin")
adminRoutes.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),         // ‚úÖ V√©rifie authentification
    // PermissionMiddleware appliqu√© par route selon besoins
)
{
    // N√©cessite le module USERS complet
    adminRoutes.GET("/users",
        PermissionMiddleware("module:USERS"),  // ‚úÖ V√©rifie permission module
        userController.ListUsers,
    )

    // N√©cessite le module ETABLISSEMENTS complet
    adminRoutes.GET("/establishments",
        PermissionMiddleware("module:ETABLISSEMENTS"),
        establishmentController.List,
    )
}
```

### **Routes PROT√âG√âES avec PERMISSIONS GRANULAIRES (rubrique sp√©cifique)**

```go
// Routes avec permissions tr√®s sp√©cifiques
backOffice := router.Group("/api/v1/back-office")
backOffice.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),          // ‚úÖ Authentification requise
    ClientTypeMiddleware("back-office"), // ‚úÖ V√©rifier que c'est bien back-office
)
{
    // Permission granulaire : rubrique sp√©cifique
    backOffice.POST("/users",
        PermissionMiddleware("rubrique:USERS:CREATE_USER"), // ‚úÖ Permission rubrique
        userController.CreateUser,
    )

    // Permission granulaire : rubrique sp√©cifique
    backOffice.DELETE("/users/:id",
        PermissionMiddleware("rubrique:USERS:DELETE_USER"),
        userController.DeleteUser,
    )

    // Module complet requis
    backOffice.GET("/establishment/licenses",
        PermissionMiddleware("module:ETABLISSEMENTS"),
        establishmentController.GetLicenses,
    )
}
```

### **Routes avec RATE LIMITING sp√©cifique**

```go
// Endpoints sensibles avec rate limiting
api := router.Group("/api/v1")
api.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),
)
{
    // Export lourd - limiter √† 10 requ√™tes par heure
    api.GET("/reports/export",
        PermissionMiddleware("module:REPORTS"),
        RateLimitMiddleware(10, time.Hour),  // Protection contre abus
        reportController.Export,
    )

    // Envoi d'emails - limiter √† 20 par minute
    api.POST("/notifications/email",
        PermissionMiddleware("module:NOTIFICATIONS"),
        RateLimitMiddleware(20, time.Minute),
        notificationController.SendEmail,
    )
}
```

## üìä Tableau R√©capitulatif - Quand Utiliser Quel Middleware

| Endpoint Type                     | SessionMiddleware  | PermissionMiddleware  | RateLimitMiddleware     | Exemple                |
| --------------------------------- | ------------------ | --------------------- | ----------------------- | ---------------------- |
| **Public** (login, ping)          | ‚ùå Non             | ‚ùå Non                | ‚úÖ Recommand√© sur login | `/auth/login`          |
| **Auth Simple** (profile, logout) | ‚úÖ **OBLIGATOIRE** | ‚ùå Non                | ‚ö†Ô∏è Optionnel            | `/auth/me`, `/profile` |
| **Module Complet**                | ‚úÖ **OBLIGATOIRE** | ‚úÖ `module:XXX`       | ‚ö†Ô∏è Optionnel            | `/users` (liste)       |
| **Rubrique Sp√©cifique**           | ‚úÖ **OBLIGATOIRE** | ‚úÖ `rubrique:XXX:YYY` | ‚ö†Ô∏è Optionnel            | `/users` (cr√©ation)    |
| **Endpoint Co√ªteux**              | ‚úÖ **OBLIGATOIRE** | ‚úÖ Selon besoin       | ‚úÖ **RECOMMAND√â**       | `/reports/export`      |

## üéØ R√®gles Simples √† Retenir

1. **SessionMiddleware** = "L'utilisateur est-il connect√© ?"

   - OBLIGATOIRE pour toute route n√©cessitant une authentification
   - V√©rifie que le token est valide et non expir√©

2. **PermissionMiddleware** = "L'utilisateur a-t-il le droit ?"

   - OPTIONNEL, uniquement si vous voulez restreindre l'acc√®s
   - Format : `module:XXX` ou `rubrique:XXX:YYY`

3. **RateLimitMiddleware** = "Protection contre les abus"
   - RECOMMAND√â sur `/auth/login` (brute force)
   - RECOMMAND√â sur endpoints co√ªteux (exports, emails)
   - OPTIONNEL ailleurs

---

## ‚ö° R√®gles de Performance

1. **Cache Redis Agressif** :

   - √âtablissement : Pas d'expiration (donn√©es immuables)
   - Licence : 24h (donn√©es semi-statiques)
   - Permissions : 1h (align√© sur session)

2. **Fail Fast** :

   - Validation format avant DB
   - Blacklist check avant session
   - Cache check avant query

3. **Pipeline Redis** :
   - Grouper op√©rations login
   - Atomic operations pour consistency

---

## üõ°Ô∏è S√©curit√©

1. **Defense in Depth** :

   - Multiple couches de validation
   - Isolation multi-tenant stricte
   - Rate limiting granulaire

2. **Audit Trail** :

   - Logging structur√© avec request_id
   - Tra√ßabilit√© compl√®te des actions
   - M√©triques pour monitoring

3. **Error Handling** :
   - Codes d'erreur sp√©cifiques
   - Messages utilisateur vs d√©tails techniques
   - Pas de leak d'informations sensibles

---

## ‚úÖ Checklist Impl√©mentation

- [ ] **Core Middlewares**

  - [ ] RecoveryMiddleware
  - [ ] LoggerMiddleware
  - [ ] CORSMiddleware
  - [ ] SecurityMiddleware

- [ ] **Multi-tenant Middlewares**

  - [ ] EstablishmentMiddleware
  - [ ] LicenseMiddleware

- [ ] **Auth Middlewares**

  - [ ] SessionMiddleware
  - [ ] PermissionMiddleware
  - [ ] ClientTypeMiddleware

- [ ] **Protection Middlewares**

  - [ ] RateLimitMiddleware
  - [ ] IPWhitelistMiddleware (optionnel)

- [ ] **Module Fx**

  - [ ] middleware.module.go avec providers
  - [ ] Configuration injection

- [ ] **Tests**
  - [ ] Tests unitaires par middleware
  - [ ] Tests d'int√©gration chain compl√®te
  - [ ] Tests de charge

---

**Ces sp√©cifications garantissent une infrastructure middleware robuste, performante et s√©curis√©e pour l'√©cosyst√®me Soins Suite.**
