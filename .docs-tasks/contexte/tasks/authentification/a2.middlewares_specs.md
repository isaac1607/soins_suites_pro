# SPÉCIFICATIONS TECHNIQUES - MIDDLEWARES CORE

## 📋 Informations Générales

- **Module :** Middlewares Infrastructure
- **Version :** 1.0 MVP
- **Priorité :** Must Have (Core Infrastructure)
- **Architecture :** Gin Middleware Chain

## 🎯 Objectif

Développer une chaîne de middlewares robuste pour :

- Sécurité multi-tenant avec isolation stricte
- Authentification et autorisation granulaire
- Performance et observabilité
- Gestion d'erreurs cohérente

## 🏗️ Architecture Middleware Chain

```
Request Flow:
┌─────────┐
│ Request │
└────┬────┘
     ↓
[RecoveryMiddleware]     // Panic recovery
     ↓
[LoggerMiddleware]       // Request/Response logging
     ↓
[CORSMiddleware]         // CORS headers
     ↓
[SecurityMiddleware]     // Security headers
     ↓
[EstablishmentMiddleware] // Multi-tenant validation
     ↓
[LicenseMiddleware]      // License validation
     ↓
[SessionMiddleware]      // Auth validation
     ↓
[PermissionMiddleware]   // Permission check
     ↓
[RateLimitMiddleware]    // Rate limiting
     ↓
┌────────────┐
│ Controller │
└────────────┘
```

## 📁 Structure des Fichiers

```
internal/shared/middleware/
├── middleware.module.go              # Module Fx principal
├── core/
│   ├── recovery.middleware.go       # Panic recovery
│   ├── logger.middleware.go         # Request logging
│   └── errors.middleware.go         # Error handling
├── security/
│   ├── cors.middleware.go           # CORS configuration
│   ├── security.middleware.go       # Security headers
│   └── ratelimit.middleware.go      # Rate limiting
├── tenant/
│   ├── establishment.middleware.go  # Multi-tenant
│   └── license.middleware.go        # License check
└── auth/
    ├── session.middleware.go        # Session validation
    └── permission.middleware.go     # Permission check
```

---

## 🔧 MIDDLEWARE 1: RecoveryMiddleware

### **Responsabilités**

- Capture des panics
- Logging des stack traces
- Réponse d'erreur propre

### **Implementation**

```go
func RecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Log stack trace
                stack := make([]byte, 4096)
                n := runtime.Stack(stack, false)

                log.Error("panic recovered",
                    "error", err,
                    "stack", string(stack[:n]),
                    "path", c.Request.URL.Path,
                )

                c.AbortWithStatusJSON(500, gin.H{
                    "error": "Une erreur interne s'est produite",
                    "details": map[string]interface{}{
                        "code": "INTERNAL_ERROR",
                        "request_id": c.GetString("request_id"),
                    },
                })
            }
        }()
        c.Next()
    }
}
```

---

## 🔧 MIDDLEWARE 2: LoggerMiddleware

### **Responsabilités**

- Génération request_id unique
- Logging requête/réponse
- Mesure latence

### **Implementation**

```go
func LoggerMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Générer request_id
        requestID := uuid.New().String()
        c.Set("request_id", requestID)

        // Start timer
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery

        // Process request
        c.Next()

        // Log après traitement
        latency := time.Since(start)
        clientIP := c.ClientIP()
        method := c.Request.Method
        statusCode := c.Writer.Status()

        if raw != "" {
            path = path + "?" + raw
        }

        log.Info("request processed",
            "request_id", requestID,
            "method", method,
            "path", path,
            "status", statusCode,
            "latency_ms", latency.Milliseconds(),
            "client_ip", clientIP,
            "establishment", c.GetHeader("X-Establishment-Code"),
        )
    }
}
```

---

## 🔧 MIDDLEWARE 3: CORSMiddleware

### **Responsabilités**

- Configuration CORS pour multi-tenant
- Support des sous-domaines dynamiques

### **Implementation**

```go
func CORSMiddleware(config *config.AppConfig) gin.HandlerFunc {
    return cors.New(cors.Config{
        AllowOriginFunc: func(origin string) bool {
            // Autoriser tous les sous-domaines *.soins-suite.tir.ci
            allowedPattern := regexp.MustCompile(
                `^https?://([a-zA-Z0-9-]+\.)?(back-office\.)?soins-suite\.tir\.ci$`,
            )
            return allowedPattern.MatchString(origin) ||
                   origin == "http://localhost:3000" // Dev
        },
        AllowMethods: []string{
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH",
        },
        AllowHeaders: []string{
            "Origin", "Content-Type", "Authorization",
            "X-Establishment-Code", "X-Client-Type",
        },
        ExposeHeaders: []string{
            "Content-Length", "X-Request-Id",
        },
        AllowCredentials: true,
        MaxAge: 12 * time.Hour,
    })
}
```

---

## 🔧 MIDDLEWARE 4: SecurityMiddleware

### **Responsabilités**

- Headers de sécurité (CSP, HSTS, etc.)
- Protection XSS/Clickjacking

### **Implementation**

```go
func SecurityMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Security headers
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

        // HSTS pour production
        if gin.Mode() == gin.ReleaseMode {
            c.Header("Strict-Transport-Security",
                "max-age=31536000; includeSubDomains; preload")
        }

        // CSP basique
        c.Header("Content-Security-Policy",
            "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'")

        c.Next()
    }
}
```

---

## 🔧 MIDDLEWARE 5: EstablishmentMiddleware

### **Responsabilités**

- Validation code établissement
- Vérification existence et statut
- Injection contexte établissement
- Cache Redis pour performance

### **Implementation**

```go
func EstablishmentMiddleware(db *postgres.Client, redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire code établissement
        code := c.GetHeader("X-Establishment-Code")
        if code == "" {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Code établissement requis",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_CODE_REQUIRED",
                    "header_required": "X-Establishment-Code",
                },
            })
            return
        }

        // 2. Validation format
        if !isValidEstablishmentCode(code) {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Format code établissement invalide",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_CODE_INVALID_FORMAT",
                    "format_requis": "3-20 caractères alphanumériques majuscules",
                },
            })
            return
        }

        // 3. Vérifier cache Redis
        cacheKey := fmt.Sprintf("soins_suite_%s_cache_middleware:establishment", code)
        cached, err := redis.Get(c.Request.Context(), cacheKey).Result()

        var establishment EstablishmentData
        if err == nil {
            // Cache hit
            json.Unmarshal([]byte(cached), &establishment)
        } else {
            // Cache miss - requête DB
            err = db.QueryRow(c.Request.Context(),
                `SELECT id, app_instance, code_etablissement, statut, nom
                 FROM base_etablissement
                 WHERE code_etablissement = $1`, code).Scan(
                &establishment.ID,
                &establishment.AppInstance,
                &establishment.Code,
                &establishment.Statut,
                &establishment.Nom,
            )

            if err != nil {
                c.AbortWithStatusJSON(460, gin.H{
                    "error": "Établissement non trouvé",
                    "details": map[string]interface{}{
                        "code": "ESTABLISHMENT_NOT_FOUND",
                        "establishment_code": code,
                    },
                })
                return
            }

            // Mettre en cache (pas d'expiration car données immuables)
            jsonData, _ := json.Marshal(establishment)
            redis.Set(c.Request.Context(), cacheKey, jsonData, 0)
        }

        // 4. Vérifier statut
        if establishment.Statut != "actif" {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Établissement suspendu",
                "details": map[string]interface{}{
                    "code": "ESTABLISHMENT_SUSPENDED",
                    "establishment_code": code,
                    "statut": establishment.Statut,
                },
            })
            return
        }

        // 5. Enrichir contexte
        c.Set("establishment", establishment)
        c.Set("establishment_id", establishment.ID)
        c.Set("establishment_code", code)

        c.Next()
    }
}
```

### **Routes Exemptées**

```go
var EstablishmentExemptPaths = []string{
    "/health",
    "/ready",
    "/metrics",
    "/api/v1/system/ping",
}
```

---

## 🔧 MIDDLEWARE 6: LicenseMiddleware

### **Responsabilités**

- Vérification licence active
- Contrôle expiration
- Validation modules autorisés
- Cache Redis 24h

### **Implementation**

```go
func LicenseMiddleware(db *postgres.Client, redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        establishmentID := c.GetString("establishment_id")

        // 1. Vérifier cache Redis
        cacheKey := fmt.Sprintf("soins_suite_%s_cache_middleware:license",
            c.GetString("establishment_code"))

        var license LicenseData
        cached, err := redis.Get(c.Request.Context(), cacheKey).Result()

        if err == nil {
            json.Unmarshal([]byte(cached), &license)
        } else {
            // Cache miss - requête DB
            err = db.QueryRow(c.Request.Context(),
                `SELECT l.id, l.type_licence, l.mode_deploiement,
                        l.statut, l.modules_autorises, l.date_expiration
                 FROM base_licence l
                 WHERE l.etablissement_id = $1
                   AND l.statut = 'actif'
                 ORDER BY l.created_at DESC
                 LIMIT 1`, establishmentID).Scan(
                &license.ID,
                &license.TypeLicence,
                &license.ModeDeploiement,
                &license.Statut,
                &license.ModulesAutorises,
                &license.DateExpiration,
            )

            if err != nil {
                c.AbortWithStatusJSON(465, gin.H{
                    "error": "Aucune licence trouvée",
                    "details": map[string]interface{}{
                        "code": "LICENSE_NOT_FOUND",
                        "establishment_code": c.GetString("establishment_code"),
                    },
                })
                return
            }

            // Cache 24h
            jsonData, _ := json.Marshal(license)
            redis.Set(c.Request.Context(), cacheKey, jsonData, 24*time.Hour)
        }

        // 2. Vérifier expiration (mode online uniquement)
        if license.ModeDeploiement == "online" && license.DateExpiration != nil {
            if time.Now().After(*license.DateExpiration) {
                c.AbortWithStatusJSON(465, gin.H{
                    "error": "Licence expirée",
                    "details": map[string]interface{}{
                        "code": "LICENSE_EXPIRED",
                        "expiration_date": license.DateExpiration,
                    },
                })
                return
            }
        }

        // 3. Enrichir contexte
        c.Set("license", license)
        c.Set("modules_autorises", license.ModulesAutorises)

        c.Next()
    }
}
```

---

## 🔧 MIDDLEWARE 7: SessionMiddleware

### **Responsabilités**

- Validation token Bearer
- Vérification session Redis
- Enrichissement contexte utilisateur
- Mise à jour last_activity

### **Implementation**

```go
func SessionMiddleware(redis *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. Extraire token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Token requis",
                "details": map[string]interface{}{
                    "code": "TOKEN_REQUIRED",
                },
            })
            return
        }

        // Format: Bearer {token}
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Format token invalide",
                "details": map[string]interface{}{
                    "code": "INVALID_TOKEN_FORMAT",
                },
            })
            return
        }

        token := parts[1]
        establishmentCode := c.GetString("establishment_code")

        // 2. Vérifier blacklist
        blacklistKey := fmt.Sprintf("soins_suite_%s_auth_blacklist:%s",
            establishmentCode, token)
        if exists := redis.Exists(c.Request.Context(), blacklistKey).Val(); exists > 0 {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Token révoqué",
                "details": map[string]interface{}{
                    "code": "TOKEN_REVOKED",
                },
            })
            return
        }

        // 3. Récupérer session
        sessionKey := fmt.Sprintf("soins_suite_%s_auth_session:%s",
            establishmentCode, token)
        sessionData := redis.HGetAll(c.Request.Context(), sessionKey).Val()

        if len(sessionData) == 0 {
            c.AbortWithStatusJSON(460, gin.H{
                "error": "Session invalide ou expirée",
                "details": map[string]interface{}{
                    "code": "SESSION_NOT_FOUND",
                },
            })
            return
        }

        // 4. Mettre à jour last_activity
        redis.HSet(c.Request.Context(), sessionKey,
            "last_activity", time.Now().Format(time.RFC3339))
        redis.Expire(c.Request.Context(), sessionKey, time.Hour)

        // 5. Enrichir contexte
        c.Set("session", sessionData)
        c.Set("user_id", sessionData["user_id"])
        c.Set("client_type", sessionData["client_type"])
        c.Set("token", token)

        c.Next()
    }
}
```

---

## 🔧 MIDDLEWARE 8: PermissionMiddleware

### **Responsabilités**

- Vérification permissions requises
- Support module/rubrique
- Cache Redis des permissions

### **Implementation**

```go
func PermissionMiddleware(required string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        establishmentCode := c.GetString("establishment_code")

        if userID == "" {
            c.AbortWithStatusJSON(401, gin.H{
                "error": "Authentification requise",
                "details": map[string]interface{}{
                    "code": "AUTH_REQUIRED",
                },
            })
            return
        }

        // Récupérer permissions depuis Redis
        permissionsKey := fmt.Sprintf("soins_suite_%s_auth_permissions:%s",
            establishmentCode, userID)

        // Parser permission requise
        parts := strings.Split(required, ":")
        permType := parts[0]  // "module" ou "rubrique"

        var hasPermission bool

        if permType == "module" {
            // Vérifier accès module complet
            hasPermission = redis.SIsMember(c.Request.Context(),
                permissionsKey, required).Val()
        } else if permType == "rubrique" && len(parts) == 3 {
            // Vérifier accès rubrique OU module complet
            module := parts[1]
            moduleAccess := fmt.Sprintf("module:%s", module)

            hasModuleAccess := redis.SIsMember(c.Request.Context(),
                permissionsKey, moduleAccess).Val()
            hasRubriqueAccess := redis.SIsMember(c.Request.Context(),
                permissionsKey, required).Val()

            hasPermission = hasModuleAccess || hasRubriqueAccess
        }

        if !hasPermission {
            c.AbortWithStatusJSON(465, gin.H{
                "error": "Permissions insuffisantes",
                "details": map[string]interface{}{
                    "code": "INSUFFICIENT_PERMISSIONS",
                    "required": required,
                },
            })
            return
        }

        c.Next()
    }
}
```

---

## 🔧 MIDDLEWARE 9: RateLimitMiddleware

### **Responsabilités**

- Protection contre les abus
- Limitation par endpoint/utilisateur
- Sliding window avec Redis

### **Implementation**

```go
func RateLimitMiddleware(limit int, window time.Duration) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("user_id")
        if userID == "" {
            userID = c.ClientIP() // Fallback sur IP si non authentifié
        }

        path := c.Request.URL.Path
        method := c.Request.Method
        establishmentCode := c.GetString("establishment_code")

        // Clé unique par utilisateur/endpoint
        key := fmt.Sprintf("soins_suite_%s_ratelimit:%s:%s:%s",
            establishmentCode, userID, method, path)

        // Incrémenter compteur
        val := redis.Incr(c.Request.Context(), key).Val()

        // Première requête : définir TTL
        if val == 1 {
            redis.Expire(c.Request.Context(), key, window)
        }

        // Vérifier limite
        if val > int64(limit) {
            ttl := redis.TTL(c.Request.Context(), key).Val()
            c.AbortWithStatusJSON(429, gin.H{
                "error": "Trop de requêtes",
                "details": map[string]interface{}{
                    "code": "RATE_LIMIT_EXCEEDED",
                    "retry_after_seconds": int(ttl.Seconds()),
                },
            })
            return
        }

        // Headers informatifs
        c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
        c.Header("X-RateLimit-Remaining", strconv.Itoa(limit-int(val)))

        c.Next()
    }
}
```

---

## 📋 Configuration des Routes - Exemples Pratiques

### **Routes PUBLIQUES (sans authentification)**

```go
// Routes accessibles sans token
public := router.Group("/api/v1")
public.Use(
    RecoveryMiddleware(),           // Protection panics
    LoggerMiddleware(),              // Logging
    CORSMiddleware(config),          // CORS
    SecurityMiddleware(),            // Headers sécurité
    EstablishmentMiddleware(db, redis), // Multi-tenant OBLIGATOIRE
)
{
    // Login - pas besoin de SessionMiddleware car c'est ici qu'on crée la session
    public.POST("/auth/login",
        RateLimitMiddleware(5, 15*time.Minute), // Max 5 tentatives / 15 min
        authController.Login,
    )

    // Endpoints système publics
    public.GET("/system/ping", systemController.Ping)
    public.GET("/health", healthController.Check)
}
```

### **Routes PROTÉGÉES SIMPLES (auth requise, pas de permission spécifique)**

```go
// Routes nécessitant juste d'être connecté
authenticated := router.Group("/api/v1")
authenticated.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),        // ✅ OBLIGATOIRE - Vérifie token valide
    // PAS de PermissionMiddleware ici - juste besoin d'être connecté
)
{
    // Endpoints accessibles à tous les utilisateurs connectés
    authenticated.GET("/auth/me", authController.GetCurrentUser)
    authenticated.POST("/auth/logout", authController.Logout)
    authenticated.POST("/auth/refresh", authController.RefreshToken)
    authenticated.GET("/profile", userController.GetMyProfile)
}
```

### **Routes PROTÉGÉES avec PERMISSIONS (module complet)**

```go
// Routes nécessitant des permissions spécifiques
adminRoutes := router.Group("/api/v1/admin")
adminRoutes.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),         // ✅ Vérifie authentification
    // PermissionMiddleware appliqué par route selon besoins
)
{
    // Nécessite le module USERS complet
    adminRoutes.GET("/users",
        PermissionMiddleware("module:USERS"),  // ✅ Vérifie permission module
        userController.ListUsers,
    )

    // Nécessite le module ETABLISSEMENTS complet
    adminRoutes.GET("/establishments",
        PermissionMiddleware("module:ETABLISSEMENTS"),
        establishmentController.List,
    )
}
```

### **Routes PROTÉGÉES avec PERMISSIONS GRANULAIRES (rubrique spécifique)**

```go
// Routes avec permissions très spécifiques
backOffice := router.Group("/api/v1/back-office")
backOffice.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),          // ✅ Authentification requise
    ClientTypeMiddleware("back-office"), // ✅ Vérifier que c'est bien back-office
)
{
    // Permission granulaire : rubrique spécifique
    backOffice.POST("/users",
        PermissionMiddleware("rubrique:USERS:CREATE_USER"), // ✅ Permission rubrique
        userController.CreateUser,
    )

    // Permission granulaire : rubrique spécifique
    backOffice.DELETE("/users/:id",
        PermissionMiddleware("rubrique:USERS:DELETE_USER"),
        userController.DeleteUser,
    )

    // Module complet requis
    backOffice.GET("/establishment/licenses",
        PermissionMiddleware("module:ETABLISSEMENTS"),
        establishmentController.GetLicenses,
    )
}
```

### **Routes avec RATE LIMITING spécifique**

```go
// Endpoints sensibles avec rate limiting
api := router.Group("/api/v1")
api.Use(
    RecoveryMiddleware(),
    LoggerMiddleware(),
    CORSMiddleware(config),
    SecurityMiddleware(),
    EstablishmentMiddleware(db, redis),
    LicenseMiddleware(db, redis),
    SessionMiddleware(redis),
)
{
    // Export lourd - limiter à 10 requêtes par heure
    api.GET("/reports/export",
        PermissionMiddleware("module:REPORTS"),
        RateLimitMiddleware(10, time.Hour),  // Protection contre abus
        reportController.Export,
    )

    // Envoi d'emails - limiter à 20 par minute
    api.POST("/notifications/email",
        PermissionMiddleware("module:NOTIFICATIONS"),
        RateLimitMiddleware(20, time.Minute),
        notificationController.SendEmail,
    )
}
```

## 📊 Tableau Récapitulatif - Quand Utiliser Quel Middleware

| Endpoint Type                     | SessionMiddleware  | PermissionMiddleware  | RateLimitMiddleware     | Exemple                |
| --------------------------------- | ------------------ | --------------------- | ----------------------- | ---------------------- |
| **Public** (login, ping)          | ❌ Non             | ❌ Non                | ✅ Recommandé sur login | `/auth/login`          |
| **Auth Simple** (profile, logout) | ✅ **OBLIGATOIRE** | ❌ Non                | ⚠️ Optionnel            | `/auth/me`, `/profile` |
| **Module Complet**                | ✅ **OBLIGATOIRE** | ✅ `module:XXX`       | ⚠️ Optionnel            | `/users` (liste)       |
| **Rubrique Spécifique**           | ✅ **OBLIGATOIRE** | ✅ `rubrique:XXX:YYY` | ⚠️ Optionnel            | `/users` (création)    |
| **Endpoint Coûteux**              | ✅ **OBLIGATOIRE** | ✅ Selon besoin       | ✅ **RECOMMANDÉ**       | `/reports/export`      |

## 🎯 Règles Simples à Retenir

1. **SessionMiddleware** = "L'utilisateur est-il connecté ?"

   - OBLIGATOIRE pour toute route nécessitant une authentification
   - Vérifie que le token est valide et non expiré

2. **PermissionMiddleware** = "L'utilisateur a-t-il le droit ?"

   - OPTIONNEL, uniquement si vous voulez restreindre l'accès
   - Format : `module:XXX` ou `rubrique:XXX:YYY`

3. **RateLimitMiddleware** = "Protection contre les abus"
   - RECOMMANDÉ sur `/auth/login` (brute force)
   - RECOMMANDÉ sur endpoints coûteux (exports, emails)
   - OPTIONNEL ailleurs

---

## ⚡ Règles de Performance

1. **Cache Redis Agressif** :

   - Établissement : Pas d'expiration (données immuables)
   - Licence : 24h (données semi-statiques)
   - Permissions : 1h (aligné sur session)

2. **Fail Fast** :

   - Validation format avant DB
   - Blacklist check avant session
   - Cache check avant query

3. **Pipeline Redis** :
   - Grouper opérations login
   - Atomic operations pour consistency

---

## 🛡️ Sécurité

1. **Defense in Depth** :

   - Multiple couches de validation
   - Isolation multi-tenant stricte
   - Rate limiting granulaire

2. **Audit Trail** :

   - Logging structuré avec request_id
   - Traçabilité complète des actions
   - Métriques pour monitoring

3. **Error Handling** :
   - Codes d'erreur spécifiques
   - Messages utilisateur vs détails techniques
   - Pas de leak d'informations sensibles

---

## ✅ Checklist Implémentation

- [ ] **Core Middlewares**

  - [ ] RecoveryMiddleware
  - [ ] LoggerMiddleware
  - [ ] CORSMiddleware
  - [ ] SecurityMiddleware

- [ ] **Multi-tenant Middlewares**

  - [ ] EstablishmentMiddleware
  - [ ] LicenseMiddleware

- [ ] **Auth Middlewares**

  - [ ] SessionMiddleware
  - [ ] PermissionMiddleware
  - [ ] ClientTypeMiddleware

- [ ] **Protection Middlewares**

  - [ ] RateLimitMiddleware
  - [ ] IPWhitelistMiddleware (optionnel)

- [ ] **Module Fx**

  - [ ] middleware.module.go avec providers
  - [ ] Configuration injection

- [ ] **Tests**
  - [ ] Tests unitaires par middleware
  - [ ] Tests d'intégration chain complète
  - [ ] Tests de charge

---

**Ces spécifications garantissent une infrastructure middleware robuste, performante et sécurisée pour l'écosystème Soins Suite.**
