# SPÃ‰CIFICATIONS TECHNIQUES - GÃ‰NÃ‰RATION DU CODE PATIENT

## ðŸ“‹ Informations GÃ©nÃ©rales

- **Module :** Core-Service Patient - GÃ©nÃ©ration Code Unique
- **Version :** 1.0
- **CriticitÃ© :** TrÃ¨s Haute (identifiant permanent du patient)
- **Performance cible :** < 50ms par gÃ©nÃ©ration

## ðŸŽ¯ Format du Code Patient

### Structure : `{CODE_ETABLISSEMENT}-{YYYY}-{NNN}-{LLL}`

```
Format: CENTREA-2025-001-AAA
        â”‚       â”‚    â”‚   â”‚
        â”‚       â”‚    â”‚   â””â”€â”€ Suffixe alphabÃ©tique (AAA Ã  ZZZ)
        â”‚       â”‚    â””â”€â”€â”€â”€â”€â”€ NumÃ©ro sÃ©quentiel (001 Ã  999)
        â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AnnÃ©e de crÃ©ation
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Code Ã©tablissement crÃ©ateur

Exemples concrets:
- CENTREA-2025-001-AAA   â†’ Premier patient 2025 du Centre A
- CENTREA-2025-999-AAA   â†’ 999Ã¨me patient du bloc AAA
- CENTREA-2025-001-AAB   â†’ 1000Ã¨me patient (nouveau bloc)
- HOPITAL-2025-001-AAA   â†’ Premier patient 2025 de l'HÃ´pital
```

### CapacitÃ©

- **Par bloc** : 999 codes (001 Ã  999)
- **Nombre de blocs** : 17 576 (AAA Ã  ZZZ)
- **Total par Ã©tablissement/an** : **17 558 424 codes**

### RÃ¨gles de Progression

1. **IncrÃ©mentation numÃ©rique** : 001 â†’ 002 â†’ ... â†’ 999
2. **Changement de bloc** : AprÃ¨s 999, retour Ã  001 avec suffixe suivant
3. **Progression alphabÃ©tique** : AAA â†’ AAB â†’ AAC â†’ ... â†’ ZZZ
4. **Reset annuel** : Chaque 1er janvier, retour Ã  001-AAA

---

## ðŸ”§ STRATÃ‰GIE DE GÃ‰NÃ‰RATION

### Approche Hybride : PostgreSQL + Redis

#### 1ï¸âƒ£ **Table de SÃ©quences PostgreSQL (Source de VÃ©ritÃ©)**

```sql
-- Table lÃ©gÃ¨re pour stocker l'Ã©tat des sÃ©quences
CREATE TABLE patients_code_sequences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    etablissement_code VARCHAR(20) NOT NULL,
    annee INTEGER NOT NULL,
    dernier_numero INTEGER DEFAULT 0,      -- 001 Ã  999
    dernier_suffixe VARCHAR(3) DEFAULT 'AAA', -- AAA Ã  ZZZ
    nombre_generes BIGINT DEFAULT 0,       -- Statistique

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT UQ_patients_sequences_etablissement_annee
        UNIQUE (etablissement_code, annee)
);

-- Index pour performance
CREATE INDEX IDX_patients_sequences_lookup
    ON patients_code_sequences (etablissement_code, annee);
```

#### 2ï¸âƒ£ **Cache Redis pour Performance**

```redis
# ClÃ© pour le dernier code gÃ©nÃ©rÃ©
Key: soins_suite_patient_sequence:{etablissement_code}:{year}
Type: STRING
Value: "999:AAB"  # Format: {numero}:{suffixe}
TTL: Jusqu'Ã  fin d'annÃ©e (calculÃ© dynamiquement)

# Lock pour Ã©viter les doublons en cas de concurrence
Key: soins_suite_patient_sequence_lock:{etablissement_code}:{year}
Type: STRING
Value: "1"
TTL: 5 secondes
```

---

## ðŸ’¡ ALGORITHME DE GÃ‰NÃ‰RATION INTELLIGENT

### Service Go OptimisÃ©

```go
package services

import (
    "context"
    "fmt"
    "sync"
    "time"
    "database/sql"
    "github.com/redis/go-redis/v9"
)

type PatientCodeGenerator struct {
    db          *postgres.Client
    redis       *redis.Client
    mu          sync.Map  // Lock en mÃ©moire par Ã©tablissement
}

// GeneratePatientCode gÃ©nÃ¨re un code patient unique atomiquement
func (g *PatientCodeGenerator) GeneratePatientCode(
    ctx context.Context,
    etablissementCode string,
) (string, error) {
    year := time.Now().Year()

    // 1. Tentative rapide via Redis (99% des cas)
    if code, err := g.generateFromRedis(ctx, etablissementCode, year); err == nil {
        return code, nil
    }

    // 2. Fallback PostgreSQL si Redis indisponible ou premiÃ¨re gÃ©nÃ©ration
    return g.generateFromPostgres(ctx, etablissementCode, year)
}

// generateFromRedis - GÃ©nÃ©ration ultra-rapide via Redis
func (g *PatientCodeGenerator) generateFromRedis(
    ctx context.Context,
    etablissementCode string,
    year int,
) (string, error) {
    redisKey := fmt.Sprintf("soins_suite_patient_sequence:%s:%d", etablissementCode, year)
    lockKey := fmt.Sprintf("soins_suite_patient_sequence_lock:%s:%d", etablissementCode, year)

    // AcquÃ©rir un lock Redis (protection concurrence)
    locked, err := g.redis.SetNX(ctx, lockKey, "1", 5*time.Second).Result()
    if err != nil || !locked {
        return "", fmt.Errorf("unable to acquire lock")
    }
    defer g.redis.Del(ctx, lockKey)

    // RÃ©cupÃ©rer la sÃ©quence actuelle
    current, err := g.redis.Get(ctx, redisKey).Result()
    if err == redis.Nil {
        // PremiÃ¨re gÃ©nÃ©ration de l'annÃ©e - initialiser depuis PostgreSQL
        return g.initializeRedisFromDB(ctx, etablissementCode, year)
    }

    // Parser et incrÃ©menter
    var numero int
    var suffixe string
    fmt.Sscanf(current, "%d:%s", &numero, &suffixe)

    numero, suffixe = g.incrementSequence(numero, suffixe)

    // Sauvegarder la nouvelle sÃ©quence
    newValue := fmt.Sprintf("%d:%s", numero, suffixe)
    ttl := g.calculateTTLUntilYearEnd()
    g.redis.Set(ctx, redisKey, newValue, ttl)

    // Mise Ã  jour asynchrone PostgreSQL (fire-and-forget)
    go g.updatePostgresAsync(etablissementCode, year, numero, suffixe)

    // Formater le code final
    return fmt.Sprintf("%s-%d-%03d-%s", etablissementCode, year, numero, suffixe), nil
}

// generateFromPostgres - GÃ©nÃ©ration avec PostgreSQL (fallback robuste)
func (g *PatientCodeGenerator) generateFromPostgres(
    ctx context.Context,
    etablissementCode string,
    year int,
) (string, error) {
    // Utiliser un lock en mÃ©moire pour Ã©viter la concurrence
    lockKey := fmt.Sprintf("%s-%d", etablissementCode, year)
    lock, _ := g.mu.LoadOrStore(lockKey, &sync.Mutex{})
    mutex := lock.(*sync.Mutex)
    mutex.Lock()
    defer mutex.Unlock()

    var numero int
    var suffixe string

    // Transaction PostgreSQL avec LOCK
    tx, err := g.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
    if err != nil {
        return "", err
    }
    defer tx.Rollback()

    // Upsert avec rÃ©cupÃ©ration atomique
    query := `
        INSERT INTO patients_code_sequences (etablissement_code, annee, dernier_numero, dernier_suffixe)
        VALUES ($1, $2, 1, 'AAA')
        ON CONFLICT (etablissement_code, annee)
        DO UPDATE SET
            dernier_numero = CASE
                WHEN patients_code_sequences.dernier_numero = 999 THEN 1
                ELSE patients_code_sequences.dernier_numero + 1
            END,
            dernier_suffixe = CASE
                WHEN patients_code_sequences.dernier_numero = 999
                THEN next_alpha_suffix(patients_code_sequences.dernier_suffixe)
                ELSE patients_code_sequences.dernier_suffixe
            END,
            nombre_generes = patients_code_sequences.nombre_generes + 1,
            updated_at = NOW()
        RETURNING dernier_numero, dernier_suffixe
    `

    err = tx.QueryRow(query, etablissementCode, year).Scan(&numero, &suffixe)
    if err != nil {
        return "", err
    }

    if err = tx.Commit(); err != nil {
        return "", err
    }

    // Synchroniser avec Redis
    redisKey := fmt.Sprintf("soins_suite_patient_sequence:%s:%d", etablissementCode, year)
    redisValue := fmt.Sprintf("%d:%s", numero, suffixe)
    g.redis.Set(ctx, redisKey, redisValue, g.calculateTTLUntilYearEnd())

    return fmt.Sprintf("%s-%d-%03d-%s", etablissementCode, year, numero, suffixe), nil
}

// incrementSequence - Logique d'incrÃ©mentation
func (g *PatientCodeGenerator) incrementSequence(numero int, suffixe string) (int, string) {
    numero++
    if numero > 999 {
        numero = 1
        suffixe = g.nextSuffix(suffixe)
    }
    return numero, suffixe
}

// nextSuffix - Calcul du suffixe suivant (AAA â†’ AAB â†’ ... â†’ ZZZ)
func (g *PatientCodeGenerator) nextSuffix(current string) string {
    if current == "ZZZ" {
        panic("CapacitÃ© maximale atteinte pour l'annÃ©e!")
    }

    chars := []byte(current)
    for i := 2; i >= 0; i-- {
        if chars[i] < 'Z' {
            chars[i]++
            break
        }
        chars[i] = 'A'
    }
    return string(chars)
}

// calculateTTLUntilYearEnd - TTL jusqu'au 31 dÃ©cembre 23:59:59
func (g *PatientCodeGenerator) calculateTTLUntilYearEnd() time.Duration {
    now := time.Now()
    endOfYear := time.Date(now.Year(), 12, 31, 23, 59, 59, 0, now.Location())
    return endOfYear.Sub(now)
}
```

### Fonction PostgreSQL Helper

```sql
-- Fonction pour calculer le suffixe suivant
CREATE OR REPLACE FUNCTION next_alpha_suffix(current_suffix VARCHAR(3))
RETURNS VARCHAR(3) AS $$
DECLARE
    chars CHAR(3)[];
    i INTEGER;
BEGIN
    IF current_suffix = 'ZZZ' THEN
        RAISE EXCEPTION 'CapacitÃ© maximale atteinte';
    END IF;

    chars := string_to_array(current_suffix, NULL);

    -- IncrÃ©menter de droite Ã  gauche
    FOR i IN REVERSE 3..1 LOOP
        IF chars[i] < 'Z' THEN
            chars[i] := chr(ascii(chars[i]) + 1);
            EXIT;
        ELSE
            chars[i] := 'A';
        END IF;
    END LOOP;

    RETURN array_to_string(chars, '');
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## âš¡ AVANTAGES DE CETTE APPROCHE

### Performance

- **Redis Hit (99%)** : < 5ms
- **PostgreSQL Fallback** : < 50ms
- **Aucun SELECT prÃ©alable** : UPSERT atomique
- **Lock minimal** : 5 secondes max

### FiabilitÃ©

- **Pas de doublons** : Locks Redis + PostgreSQL
- **Haute disponibilitÃ©** : Fallback automatique
- **Recovery automatique** : Redis se resynchronise depuis DB
- **Audit trail** : `nombre_generes` pour statistiques

### SimplicitÃ©

- **Une seule table** : Pas de complexitÃ©
- **Code lisible** : Logique claire
- **Maintenance facile** : Ã‰tat visible dans DB
- **Pas de dÃ©pendances** : PostgreSQL + Redis suffisent

---

## ðŸ”’ GESTION DES CAS LIMITES

### 1. Redis Down

â†’ Bascule automatique sur PostgreSQL (50ms au lieu de 5ms)

### 2. Pic de Charge (1000 crÃ©ations/seconde)

â†’ Locks distribuÃ©s Redis + mutex Go en mÃ©moire

### 3. Changement d'AnnÃ©e

â†’ TTL Redis expire automatiquement, nouvelle sÃ©quence crÃ©Ã©e

### 4. CapacitÃ© Maximale (ZZZ-999)

â†’ Exception levÃ©e, alerte administrateur

### 5. Corruption Redis

â†’ Resynchronisation depuis PostgreSQL au prochain appel

---

## ðŸ“Š MONITORING & MÃ‰TRIQUES

### RequÃªtes SQL de Monitoring

```sql
-- Statistiques par Ã©tablissement
SELECT
    etablissement_code,
    annee,
    dernier_numero || '-' || dernier_suffixe as dernier_code,
    nombre_generes,
    ROUND(nombre_generes::numeric / 17558424 * 100, 2) as pourcentage_utilise
FROM patients_code_sequences
WHERE annee = EXTRACT(YEAR FROM CURRENT_DATE)
ORDER BY nombre_generes DESC;

-- Projection Ã©puisement
SELECT
    etablissement_code,
    nombre_generes,
    ROUND(nombre_generes::numeric / EXTRACT(DOY FROM CURRENT_DATE)) as moyenne_jour,
    CASE
        WHEN nombre_generes = 0 THEN 'Infini'
        ELSE (17558424 - nombre_generes) / NULLIF(nombre_generes / EXTRACT(DOY FROM CURRENT_DATE), 0) || ' jours'
    END as jours_avant_epuisement
FROM patients_code_sequences
WHERE annee = EXTRACT(YEAR FROM CURRENT_DATE);
```

### MÃ©triques Prometheus

```go
var (
    patientCodeGenerated = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "patient_code_generated_total",
            Help: "Total number of patient codes generated",
        },
        []string{"establishment", "source"}, // source: redis ou postgres
    )

    patientCodeGenerationDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "patient_code_generation_duration_seconds",
            Help: "Duration of patient code generation",
        },
        []string{"establishment", "source"},
    )
)
```

---

## âœ… CHECKLIST IMPLÃ‰MENTATION

- [ ] CrÃ©er table `patients_code_sequences`
- [ ] ImplÃ©menter fonction PostgreSQL `next_alpha_suffix`
- [ ] DÃ©velopper service Go `PatientCodeGenerator`
- [ ] Configurer TTL Redis dynamique
- [ ] Ajouter mÃ©triques Prometheus
- [ ] Tests de charge (1000 req/s)
- [ ] Tests de rÃ©silience (Redis down)
- [ ] Documentation API
- [ ] Monitoring dashboard

---

**Cette solution garantit une gÃ©nÃ©ration de codes patients unique, performante et resiliente, sans complexitÃ© excessive.**
