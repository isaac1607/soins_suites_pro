# SPÉCIFICATIONS TECHNIQUES - GÉNÉRATION DU CODE PATIENT

## 📋 Informations Générales

- **Module :** Core-Service Patient - Génération Code Unique
- **Version :** 1.0
- **Criticité :** Très Haute (identifiant permanent du patient)
- **Performance cible :** < 50ms par génération

## 🎯 Format du Code Patient

### Structure : `{CODE_ETABLISSEMENT}-{YYYY}-{NNN}-{LLL}`

```
Format: CENTREA-2025-001-AAA
        │       │    │   │
        │       │    │   └── Suffixe alphabétique (AAA à ZZZ)
        │       │    └────── Numéro séquentiel (001 à 999)
        │       └────────── Année de création
        └────────────────── Code établissement créateur

Exemples concrets:
- CENTREA-2025-001-AAA   → Premier patient 2025 du Centre A
- CENTREA-2025-999-AAA   → 999ème patient du bloc AAA
- CENTREA-2025-001-AAB   → 1000ème patient (nouveau bloc)
- HOPITAL-2025-001-AAA   → Premier patient 2025 de l'Hôpital
```

### Capacité

- **Par bloc** : 999 codes (001 à 999)
- **Nombre de blocs** : 17 576 (AAA à ZZZ)
- **Total par établissement/an** : **17 558 424 codes**

### Règles de Progression

1. **Incrémentation numérique** : 001 → 002 → ... → 999
2. **Changement de bloc** : Après 999, retour à 001 avec suffixe suivant
3. **Progression alphabétique** : AAA → AAB → AAC → ... → ZZZ
4. **Reset annuel** : Chaque 1er janvier, retour à 001-AAA

---

## 🔧 STRATÉGIE DE GÉNÉRATION

### Approche Hybride : PostgreSQL + Redis

#### 1️⃣ **Table de Séquences PostgreSQL (Source de Vérité)**

```sql
-- Table légère pour stocker l'état des séquences
CREATE TABLE patients_code_sequences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    etablissement_code VARCHAR(20) NOT NULL,
    annee INTEGER NOT NULL,
    dernier_numero INTEGER DEFAULT 0,      -- 001 à 999
    dernier_suffixe VARCHAR(3) DEFAULT 'AAA', -- AAA à ZZZ
    nombre_generes BIGINT DEFAULT 0,       -- Statistique

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT UQ_patients_sequences_etablissement_annee
        UNIQUE (etablissement_code, annee)
);

-- Index pour performance
CREATE INDEX IDX_patients_sequences_lookup
    ON patients_code_sequences (etablissement_code, annee);
```

#### 2️⃣ **Cache Redis pour Performance**

```redis
# Clé pour le dernier code généré
Key: soins_suite_patient_sequence:{etablissement_code}:{year}
Type: STRING
Value: "999:AAB"  # Format: {numero}:{suffixe}
TTL: Jusqu'à fin d'année (calculé dynamiquement)

# Lock pour éviter les doublons en cas de concurrence
Key: soins_suite_patient_sequence_lock:{etablissement_code}:{year}
Type: STRING
Value: "1"
TTL: 5 secondes
```

---

## 💡 ALGORITHME DE GÉNÉRATION INTELLIGENT

### Service Go Optimisé

```go
package services

import (
    "context"
    "fmt"
    "sync"
    "time"
    "database/sql"
    "github.com/redis/go-redis/v9"
)

type PatientCodeGenerator struct {
    db          *postgres.Client
    redis       *redis.Client
    mu          sync.Map  // Lock en mémoire par établissement
}

// GeneratePatientCode génère un code patient unique atomiquement
func (g *PatientCodeGenerator) GeneratePatientCode(
    ctx context.Context,
    etablissementCode string,
) (string, error) {
    year := time.Now().Year()

    // 1. Tentative rapide via Redis (99% des cas)
    if code, err := g.generateFromRedis(ctx, etablissementCode, year); err == nil {
        return code, nil
    }

    // 2. Fallback PostgreSQL si Redis indisponible ou première génération
    return g.generateFromPostgres(ctx, etablissementCode, year)
}

// generateFromRedis - Génération ultra-rapide via Redis
func (g *PatientCodeGenerator) generateFromRedis(
    ctx context.Context,
    etablissementCode string,
    year int,
) (string, error) {
    redisKey := fmt.Sprintf("soins_suite_patient_sequence:%s:%d", etablissementCode, year)
    lockKey := fmt.Sprintf("soins_suite_patient_sequence_lock:%s:%d", etablissementCode, year)

    // Acquérir un lock Redis (protection concurrence)
    locked, err := g.redis.SetNX(ctx, lockKey, "1", 5*time.Second).Result()
    if err != nil || !locked {
        return "", fmt.Errorf("unable to acquire lock")
    }
    defer g.redis.Del(ctx, lockKey)

    // Récupérer la séquence actuelle
    current, err := g.redis.Get(ctx, redisKey).Result()
    if err == redis.Nil {
        // Première génération de l'année - initialiser depuis PostgreSQL
        return g.initializeRedisFromDB(ctx, etablissementCode, year)
    }

    // Parser et incrémenter
    var numero int
    var suffixe string
    fmt.Sscanf(current, "%d:%s", &numero, &suffixe)

    numero, suffixe = g.incrementSequence(numero, suffixe)

    // Sauvegarder la nouvelle séquence
    newValue := fmt.Sprintf("%d:%s", numero, suffixe)
    ttl := g.calculateTTLUntilYearEnd()
    g.redis.Set(ctx, redisKey, newValue, ttl)

    // Mise à jour asynchrone PostgreSQL (fire-and-forget)
    go g.updatePostgresAsync(etablissementCode, year, numero, suffixe)

    // Formater le code final
    return fmt.Sprintf("%s-%d-%03d-%s", etablissementCode, year, numero, suffixe), nil
}

// generateFromPostgres - Génération avec PostgreSQL (fallback robuste)
func (g *PatientCodeGenerator) generateFromPostgres(
    ctx context.Context,
    etablissementCode string,
    year int,
) (string, error) {
    // Utiliser un lock en mémoire pour éviter la concurrence
    lockKey := fmt.Sprintf("%s-%d", etablissementCode, year)
    lock, _ := g.mu.LoadOrStore(lockKey, &sync.Mutex{})
    mutex := lock.(*sync.Mutex)
    mutex.Lock()
    defer mutex.Unlock()

    var numero int
    var suffixe string

    // Transaction PostgreSQL avec LOCK
    tx, err := g.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
    if err != nil {
        return "", err
    }
    defer tx.Rollback()

    // Upsert avec récupération atomique
    query := `
        INSERT INTO patients_code_sequences (etablissement_code, annee, dernier_numero, dernier_suffixe)
        VALUES ($1, $2, 1, 'AAA')
        ON CONFLICT (etablissement_code, annee)
        DO UPDATE SET
            dernier_numero = CASE
                WHEN patients_code_sequences.dernier_numero = 999 THEN 1
                ELSE patients_code_sequences.dernier_numero + 1
            END,
            dernier_suffixe = CASE
                WHEN patients_code_sequences.dernier_numero = 999
                THEN next_alpha_suffix(patients_code_sequences.dernier_suffixe)
                ELSE patients_code_sequences.dernier_suffixe
            END,
            nombre_generes = patients_code_sequences.nombre_generes + 1,
            updated_at = NOW()
        RETURNING dernier_numero, dernier_suffixe
    `

    err = tx.QueryRow(query, etablissementCode, year).Scan(&numero, &suffixe)
    if err != nil {
        return "", err
    }

    if err = tx.Commit(); err != nil {
        return "", err
    }

    // Synchroniser avec Redis
    redisKey := fmt.Sprintf("soins_suite_patient_sequence:%s:%d", etablissementCode, year)
    redisValue := fmt.Sprintf("%d:%s", numero, suffixe)
    g.redis.Set(ctx, redisKey, redisValue, g.calculateTTLUntilYearEnd())

    return fmt.Sprintf("%s-%d-%03d-%s", etablissementCode, year, numero, suffixe), nil
}

// incrementSequence - Logique d'incrémentation
func (g *PatientCodeGenerator) incrementSequence(numero int, suffixe string) (int, string) {
    numero++
    if numero > 999 {
        numero = 1
        suffixe = g.nextSuffix(suffixe)
    }
    return numero, suffixe
}

// nextSuffix - Calcul du suffixe suivant (AAA → AAB → ... → ZZZ)
func (g *PatientCodeGenerator) nextSuffix(current string) string {
    if current == "ZZZ" {
        panic("Capacité maximale atteinte pour l'année!")
    }

    chars := []byte(current)
    for i := 2; i >= 0; i-- {
        if chars[i] < 'Z' {
            chars[i]++
            break
        }
        chars[i] = 'A'
    }
    return string(chars)
}

// calculateTTLUntilYearEnd - TTL jusqu'au 31 décembre 23:59:59
func (g *PatientCodeGenerator) calculateTTLUntilYearEnd() time.Duration {
    now := time.Now()
    endOfYear := time.Date(now.Year(), 12, 31, 23, 59, 59, 0, now.Location())
    return endOfYear.Sub(now)
}
```

### Fonction PostgreSQL Helper

```sql
-- Fonction pour calculer le suffixe suivant
CREATE OR REPLACE FUNCTION next_alpha_suffix(current_suffix VARCHAR(3))
RETURNS VARCHAR(3) AS $$
DECLARE
    chars CHAR(3)[];
    i INTEGER;
BEGIN
    IF current_suffix = 'ZZZ' THEN
        RAISE EXCEPTION 'Capacité maximale atteinte';
    END IF;

    chars := string_to_array(current_suffix, NULL);

    -- Incrémenter de droite à gauche
    FOR i IN REVERSE 3..1 LOOP
        IF chars[i] < 'Z' THEN
            chars[i] := chr(ascii(chars[i]) + 1);
            EXIT;
        ELSE
            chars[i] := 'A';
        END IF;
    END LOOP;

    RETURN array_to_string(chars, '');
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## ⚡ AVANTAGES DE CETTE APPROCHE

### Performance

- **Redis Hit (99%)** : < 5ms
- **PostgreSQL Fallback** : < 50ms
- **Aucun SELECT préalable** : UPSERT atomique
- **Lock minimal** : 5 secondes max

### Fiabilité

- **Pas de doublons** : Locks Redis + PostgreSQL
- **Haute disponibilité** : Fallback automatique
- **Recovery automatique** : Redis se resynchronise depuis DB
- **Audit trail** : `nombre_generes` pour statistiques

### Simplicité

- **Une seule table** : Pas de complexité
- **Code lisible** : Logique claire
- **Maintenance facile** : État visible dans DB
- **Pas de dépendances** : PostgreSQL + Redis suffisent

---

## 🔒 GESTION DES CAS LIMITES

### 1. Redis Down

→ Bascule automatique sur PostgreSQL (50ms au lieu de 5ms)

### 2. Pic de Charge (1000 créations/seconde)

→ Locks distribués Redis + mutex Go en mémoire

### 3. Changement d'Année

→ TTL Redis expire automatiquement, nouvelle séquence créée

### 4. Capacité Maximale (ZZZ-999)

→ Exception levée, alerte administrateur

### 5. Corruption Redis

→ Resynchronisation depuis PostgreSQL au prochain appel

---

## 📊 MONITORING & MÉTRIQUES

### Requêtes SQL de Monitoring

```sql
-- Statistiques par établissement
SELECT
    etablissement_code,
    annee,
    dernier_numero || '-' || dernier_suffixe as dernier_code,
    nombre_generes,
    ROUND(nombre_generes::numeric / 17558424 * 100, 2) as pourcentage_utilise
FROM patients_code_sequences
WHERE annee = EXTRACT(YEAR FROM CURRENT_DATE)
ORDER BY nombre_generes DESC;

-- Projection épuisement
SELECT
    etablissement_code,
    nombre_generes,
    ROUND(nombre_generes::numeric / EXTRACT(DOY FROM CURRENT_DATE)) as moyenne_jour,
    CASE
        WHEN nombre_generes = 0 THEN 'Infini'
        ELSE (17558424 - nombre_generes) / NULLIF(nombre_generes / EXTRACT(DOY FROM CURRENT_DATE), 0) || ' jours'
    END as jours_avant_epuisement
FROM patients_code_sequences
WHERE annee = EXTRACT(YEAR FROM CURRENT_DATE);
```

### Métriques Prometheus

```go
var (
    patientCodeGenerated = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "patient_code_generated_total",
            Help: "Total number of patient codes generated",
        },
        []string{"establishment", "source"}, // source: redis ou postgres
    )

    patientCodeGenerationDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "patient_code_generation_duration_seconds",
            Help: "Duration of patient code generation",
        },
        []string{"establishment", "source"},
    )
)
```

---

## ✅ CHECKLIST IMPLÉMENTATION

- [ ] Créer table `patients_code_sequences`
- [ ] Implémenter fonction PostgreSQL `next_alpha_suffix`
- [ ] Développer service Go `PatientCodeGenerator`
- [ ] Configurer TTL Redis dynamique
- [ ] Ajouter métriques Prometheus
- [ ] Tests de charge (1000 req/s)
- [ ] Tests de résilience (Redis down)
- [ ] Documentation API
- [ ] Monitoring dashboard

---

**Cette solution garantit une génération de codes patients unique, performante et resiliente, sans complexité excessive.**
